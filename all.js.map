{"version":3,"sources":["DinoGame/scripts/Bird.js","DinoGame/scripts/connectionGene.js","DinoGame/scripts/connectionHistory.js","DinoGame/scripts/DinoGame.js","DinoGame/scripts/Genome.js","DinoGame/scripts/Ground.js","DinoGame/scripts/Node.js","DinoGame/scripts/Obstacle.js","DinoGame/scripts/Player.js","DinoGame/scripts/Population.js","DinoGame/scripts/Species.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClhBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3jBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"all.js","sourcesContent":["class Bird {\r\n  //------------------------------------------------------------------------------------------------------------------------------------------------------\r\n  //constructor\r\n  constructor(type) {\r\n    this.w = 60 * scl;\r\n    this.h = 50 * scl;\r\n    this.posY;\r\n    this.flapCount = 0;\r\n    this.posX = width;\r\n    this.typeOfBird = type;\r\n    switch (type) {\r\n      case 0://flying low\r\n        this.posY = 10 + this.h / 2 * scl;\r\n        break;\r\n      case 1://flying middle\r\n        this.posY = 100 * scl;\r\n        break;\r\n      case 2://flying high\r\n        this.posY = 180 * scl;\r\n        break;\r\n    }\r\n  }\r\n  //------------------------------------------------------------------------------------------------------------------------------------------------------\r\n  //show the birf\r\n  show() {\r\n    this.flapCount++;\r\n\r\n    if (this.flapCount < 0) {//flap the berd\r\n      image(bird, this.posX - bird.width * scl / 2, height - groundHeight - (this.posY + bird.height * scl) - 20 * scl, bird.width * scl, bird.height * scl);\r\n    } else {\r\n      image(bird1, this.posX - bird1.width * scl / 2, height - groundHeight - (this.posY + bird1.height * scl) - 20 * scl, bird1.width * scl, bird1.height * scl);\r\n    }\r\n    if (this.flapCount > 15) {\r\n      this.flapCount = -15;\r\n\r\n    }\r\n  }\r\n  //------------------------------------------------------------------------------------------------------------------------------------------------------\r\n  //move the bard\r\n  move(speed) {\r\n    this.posX -= speed;\r\n  }\r\n  //------------------------------------------------------------------------------------------------------------------------------------------------------\r\n  //returns whether or not the bird collides with the player\r\n  collided(playerX, playerY, playerWidth, playerHeight) {\r\n\r\n    var playerLeft = playerX - playerWidth / 2;\r\n    var playerRight = playerX + playerWidth / 2;\r\n    var thisLeft = this.posX - this.w / 2;\r\n    var thisRight = this.posX + this.w / 2;\r\n\r\n    if ((playerLeft <= thisRight && playerRight >= thisLeft) || (thisLeft <= playerRight && thisRight >= playerLeft)) {\r\n      var playerUp = playerY + playerHeight / 2;\r\n      var playerDown = playerY - playerHeight / 2;\r\n      var thisUp = this.posY + this.h / 2;\r\n      var thisDown = this.posY - this.h / 2;\r\n      if (playerDown <= thisUp && playerUp >= thisDown) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n}","//a connection between 2 nodes\r\nclass connectionGene {\r\n  constructor(from, to, w, inno) {\r\n    this.fromNode = from;\r\n    this.toNode = to;\r\n    this.weight = w;\r\n    this.enabled = true;\r\n    this.innovationNo = inno;\r\n\r\n  }\r\n\r\n  fromJSON(obj) {\r\n    this.fromNode = new Node().fromJSON(obj.fromNode);\r\n    this.toNode = new Node().fromJSON(obj.toNode);\r\n    this.weight = obj.weight;\r\n    this.enabled = obj.enabled;\r\n    this.innovationNo = obj.innovationNo;\r\n    return this;\r\n  }\r\n\r\n  //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n  //changes the weight\r\n  mutateWeight() {\r\n    var rand2 = random(1);\r\n    if (rand2 < 0.1) {//10% of the time completely change the weight\r\n      this.weight = random(-1, 1);\r\n    } else {//otherwise slightly change it\r\n      this.weight += randomGaussian() / 50;\r\n      //keep weight between bounds\r\n      if (this.weight > 1) {\r\n        this.weight = 1;\r\n      }\r\n      if (this.weight < -1) {\r\n        this.weight = -1;\r\n\r\n      }\r\n    }\r\n  }\r\n\r\n  //----------------------------------------------------------------------------------------------------------\r\n  //returns a copy of this connectionGene\r\n  clone(from, to) {\r\n    var clone = new connectionGene(from, to, this.weight, this.innovationNo);\r\n    clone.enabled = this.enabled;\r\n\r\n    return clone;\r\n  }\r\n\r\n  cloneForJSON(from, to) {\r\n    from = from.cloneForJSON();\r\n    to = to.cloneForJSON();\r\n    var clone = new connectionGene(from, to, this.weight, this.innovationNo);\r\n    clone.enabled = this.enabled;\r\n\r\n    return clone;\r\n  }\r\n}","class connectionHistory {\r\n\r\n  constructor(from, to, inno, innovationNos) {\r\n    this.fromNode = from;\r\n    this.toNode = to;\r\n    this.innovationNumber = inno;\r\n    this.innovationNumbers = [];\r\n    if (innovationNos.length > 0) {\r\n      arrayCopy(innovationNos, this.innovationNumbers);\r\n    }\r\n  }\r\n  //---------------------------------------------------------------------------------------------------------------------------------------------------------\r\n  //returns whether the genome matches the original genome and the connection is between the same nodes\r\n  matches(genome, from, to) {\r\n    if (genome.genes.length === this.innovationNumbers.length) { //if the number of connections are different then the genoemes aren't the same\r\n      if (from.number === this.fromNode && to.number === this.toNode) {\r\n        //next check if all the innovation numbers match from the genome\r\n        for (var i = 0; i < genome.genes.length; i++) {\r\n          if (!this.innovationNumbers.includes(genome.genes[i].innovationNo)) {\r\n            return false;\r\n          }\r\n        }\r\n\r\n        //if reached this far then the innovationNumbers match the genes innovation numbers and the connection is between the same nodes\r\n        //so it does match\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n}","// const { load } = require(\"libraries/p5\");\r\n\r\n//Globals\r\nvar nextConnectionNo = 1000;\r\nvar population;\r\nvar scl = .5;\r\nvar frameSpeed = 60;\r\n\r\n\r\n// variable set from outside\r\n// var showBestEachGen = true;\r\nvar loadGenFromFile = false;\r\nvar upToGen = 0;\r\nvar genPlayerTemp;\r\n// var stage = 0;\r\nvar showNothing = false;\r\n\r\n\r\n//images\r\nvar dinoRun1;\r\nvar dinoRun2;\r\nvar dinoJump;\r\nvar dinoDuck;\r\nvar dinoDuck1;\r\nvar smallCactus;\r\nvar manySmallCactus;\r\nvar bigCactus;\r\nvar bird;\r\nvar bird1;\r\n\r\n\r\nvar obstacles = [];\r\nvar birds = [];\r\nvar grounds = [];\r\n\r\n\r\nvar obstacleTimer = 0;\r\nvar minimumTimeBetweenObstacles = 90;\r\nvar randomAddition = 0;\r\nvar groundCounter = 0;\r\nconst speed_scl = scl;\r\nconst default_speed = 10 * speed_scl;\r\nvar speed = default_speed;\r\nconst speedIncrement = 0.002;\r\nconst smallJumpGravity = 1.2 * scl;\r\nconst bigJumpGravity = 1 * scl;\r\nconst duckGravity = 3 * scl;\r\nconst playerDefaultGravity = 1.2 * scl;\r\nconst highJumpY = 20 * scl;\r\nconst lowJumpY = 16 * scl;\r\nconst playerSize = 20 * scl;\r\n\r\nvar groundHeight = 300 * scl;\r\nvar playerXpos = 150 * scl;\r\n\r\nvar obstacleHistory = [];\r\nvar randomAdditionHistory = [];\r\nvar loadedBestsFromJson;\r\nvar loadedGenFromJSON;\r\n\r\nvar writeInfoX = 400 * scl;\r\nvar writeInfoPadding = 20 * scl;\r\nvar brainWidth = 400 * scl;\r\nvar brainHeight = 350 * scl;\r\n\r\nvar cWidth;\r\nvar cHeight;\r\n\r\nvar fontRegular, fontBold, fontExtraBold, fontLight, fontMedium, fontSemiBold, fontItalic;\r\n\r\nconst error = new Error(\"Should not end here\")\r\nerror.code = \"101\";\r\n\r\n//--------------------------------------------------------------------------------------------------------------------------------------------------\r\nfunction preload() {\r\n  // if (showBestEachGen) {\r\n  //   loadedBestsFromJson = loadJSON(\"DinoGame/examples/bestplayers.json\");\r\n  // }\r\n  // if (loadGenFromFile) {\r\n  //   loadedGenFromJSON = loadJSON(\"DinoGame/examples/population (2).json\");\r\n  // }\r\n  // console.log(loadedJSON);\r\n  fontRegular = loadFont('../fonts/Raleway-Regular.ttf');\r\n  fontBold = loadFont('../fonts/Raleway-Bold.ttf');\r\n}\r\n\r\n\r\nfunction setup() {\r\n  cWidth = windowWidth;\r\n  cHeight = windowHeight-235;\r\n  // console.log(loadedJSON);\r\n  frameRate(60);\r\n  var canvas = createCanvas(cWidth, cHeight);\r\n  canvas.style('display', 'block');\r\n  canvas.parent('pt');\r\n  // window.canvas = canvas;\r\n  // canvas.parent(\"canvas\");\r\n  // console.log(document.getElementById(\"main\").style.marginLeft, windowHeight);\r\n  dinoRun1 = loadImage(\"DinoGame/data/dinorun0000.png\");\r\n  dinoRun2 = loadImage(\"DinoGame/data/dinorun0001.png\");\r\n  dinoJump = loadImage(\"DinoGame/data/dinoJump0000.png\");\r\n  dinoDuck = loadImage(\"DinoGame/data/dinoduck0000.png\");\r\n  dinoDuck1 = loadImage(\"DinoGame/data/dinoduck0001.png\");\r\n\r\n  smallCactus = loadImage(\"DinoGame/data/cactusSmall0000.png\");\r\n  bigCactus = loadImage(\"DinoGame/data/cactusBig0000.png\");\r\n  manySmallCactus = loadImage(\"DinoGame/data/cactusSmallMany0000.png\");\r\n  bird = loadImage(\"DinoGame/data/berd.png\");\r\n  bird1 = loadImage(\"DinoGame/data/berd2.png\");\r\n\r\n  population = new Population(0); //<<number of dinosaurs in each generation\r\n\r\n  if (showBestEachGen) {\r\n    population.genPlayers = [];\r\n    for (var key in loadedBestsFromJson) {\r\n      var player = new Player().fromJSON(loadedBestsFromJson[key]);\r\n      population.genPlayers.push(player);\r\n    }\r\n    upToGen = 0;\r\n    genPlayerTemp = population.genPlayers[upToGen].cloneForReplay();\r\n  }\r\n  else {\r\n    if (loadGenFromFile) {\r\n      population = population.fromJSON(loadedGenFromJSON);\r\n    }\r\n    else {\r\n      population = new Population(500); //<<number of dinosaurs in each generation\r\n    }\r\n  }\r\n\r\n}\r\n\r\n//--------------------------------------------------------------------------------------------------------------------------------------------------------\r\nfunction windowResized() {\r\n  cWidth = windowWidth;\r\n  cHeight = windowHeight-235;\r\n  resizeCanvas(cWidth, cHeight);\r\n}\r\n//--------------------------------------------------------------------------------------------------------------------------------------------------------\r\nfunction draw() {\r\n  drawToScreen();\r\n  if (showBestEachGen) {//show the best of each gen\r\n    showBestPlayersForEachGeneration();\r\n  } else {//if just evolving normally\r\n    if (!population.done()) {//if any players are alive then update them\r\n      updateObstacles();\r\n      population.updateAlive();\r\n    } else {//all dead\r\n      //genetic algorithm \r\n      // stage = 0;\r\n      population.naturalSelection();\r\n      resetObstacles();\r\n    }\r\n  }\r\n}\r\n\r\nfunction touchEnded() {\r\n  return true;\r\n}\r\n\r\n//-----------------------------------------------------------------------------------\r\nfunction showBestPlayersForEachGeneration() {\r\n  if (!genPlayerTemp.dead) {//if current gen player is not dead then update it\r\n    genPlayerTemp.updateLocalObstacles();\r\n    genPlayerTemp.look();\r\n    genPlayerTemp.think();\r\n    genPlayerTemp.update();\r\n    genPlayerTemp.show();\r\n  } else {//if dead move on to the next generation\r\n    upToGen++;\r\n    var isMobile = false;\r\n    if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {\r\n      isMobile = true;\r\n    }\r\n    if (upToGen >= population.genPlayers.length\r\n      || (isMobile && genPlayerTemp.gen == 12) //for small devices\r\n    ) {//if at the end then return to the start and stop doing it\r\n      upToGen = 0;\r\n      genPlayerTemp = population.genPlayers[upToGen].cloneForReplay();\r\n      // showBestEachGen = false;\r\n    } else {//if not at the end then get the next generation\r\n      genPlayerTemp = population.genPlayers[upToGen].cloneForReplay();\r\n    }\r\n  }\r\n}\r\n//-----------------------------------------------------------------------------------\r\n\r\n\r\n\r\n//---------------------------------------------------------------------------------------------------------------------------------------------------------\r\n//draws the display screen\r\nfunction drawToScreen() {\r\n  if (!showNothing) {\r\n    if (cWidth > 800) {\r\n      groundHeight = 300 * scl;\r\n    }\r\n    else if (cWidth > 600) {\r\n      groundHeight = 250 * scl;\r\n    }\r\n    else {\r\n      groundHeight = 200 * scl;\r\n    }\r\n    background(255);\r\n    stroke(0);\r\n    strokeWeight(2);\r\n    line(0, height - groundHeight - 30 * scl, width, height - groundHeight - 30 * scl); // ground\r\n    drawBrain();\r\n    writeInfo();\r\n  }\r\n}\r\n//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\nfunction drawBrain() {  //show the brain of whatever genome is currently showing\r\n  var startX = (cWidth - brainWidth) / 2;\r\n  var startY = writeInfoPadding;\r\n  var w = brainWidth;\r\n  var h = brainHeight;\r\n  startY += 50;\r\n  if (showBestEachGen) {\r\n    genPlayerTemp.brain.drawGenome(startX, startY, w, h);\r\n  } else {\r\n    for (var i = 0; i < population.pop.length; i++) {\r\n      if (!population.pop[i].dead) {\r\n        population.pop[i].brain.drawGenome(startX, startY, w, h);\r\n        break;\r\n      }\r\n    }\r\n  }\r\n}\r\n//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n//writes info about the current player\r\nfunction writeInfo() {\r\n  noStroke();\r\n  if (showBestEachGen) { //if showing the best for each gen then write the applicable info\r\n    if (cWidth > 800) {\r\n      textSize(18);\r\n\r\n      textFont(fontRegular);\r\n      textAlign(LEFT);\r\n      fill('#1B242F');\r\n      text(\"Score: \", 30, height - 30);\r\n\r\n      fill('#036367');\r\n      text(genPlayerTemp.score, 90, height - 30);\r\n\r\n      //text(, width/2-180, height-30);\r\n      textAlign(CENTER);\r\n      // text(\"Teaching Dino to play automatically using Artificial Intelligence\", width / 2, height - 50);\r\n      fill('#1B242F');\r\n      text(\"Teaching 'Dino' to play automatically using \", width / 2 - 88, height - 30);\r\n      textFont(fontBold);\r\n      fill('#036367');\r\n      text(\"Artificial Intelligence\", width / 2 + 190, height - 30);\r\n\r\n      textFont(fontRegular);\r\n      textAlign(RIGHT);\r\n      fill('#1B242F');\r\n      text(\"Gen: \", width - 55, height - 30);\r\n      fill('#036367');\r\n      text((genPlayerTemp.gen + 1), width - 30, height - 30);\r\n    }\r\n    else {\r\n      textSize(14);\r\n\r\n      textFont(fontRegular);\r\n      textAlign(LEFT);\r\n      fill('#1B242F');\r\n      text(\"S: \", 15, height - 25);\r\n\r\n      fill('#036367');\r\n      text(genPlayerTemp.score, 30, height - 25);\r\n\r\n      //text(, width/2-180, height-30);\r\n      fill('#1B242F');\r\n      textAlign(CENTER);\r\n      // text(\"Teaching Dino to play automatically using\", width / 2, height - 50);\r\n      textFont(fontRegular);\r\n      text(\"Teaching 'Dino' to play automatically using \", width / 2, height - 50);\r\n      textFont(fontBold);\r\n      fill('#036367');\r\n      text(\"Artificial Intelligence\", width / 2, height - 30);\r\n\r\n      textFont(fontRegular);\r\n      textAlign(RIGHT);\r\n      fill('#1B242F');\r\n      text(\"G: \", width - 25, height - 25);\r\n      fill('#036367');\r\n      text((genPlayerTemp.gen + 1), width - 15, height - 25);\r\n    }\r\n    textSize(15);\r\n    // var x = writeInfoX - writeInfoPadding / 2;\r\n    // var y = writeInfoPadding + 5;\r\n    // text(\"Next Obstacle\", x, y + 44.44444);\r\n    // text(\"Height of obstacle\", x, y + 2 * 44.44444);\r\n    // text(\"Width of obstacle\", x, y + 3 * 44.44444);\r\n    // text(\"Bird height\", x, y + 4 * 44.44444);\r\n    // text(\"Speed\", x, y + 5 * 44.44444);\r\n    // text(\"Players Y position\", x, y + 6 * 44.44444);\r\n    // text(\"Gap between obstacles\", x, y + 7 * 44.44444);\r\n    // text(\"Bias\", x, y + 8 * 44.44444);\r\n\r\n    // textAlign(LEFT);\r\n    // var outputx = writeInfoX + writeInfoPadding + brainWidth + writeInfoPadding / 2;\r\n    // text(\"Small Jump\", outputx, 125);\r\n    // text(\"Big Jump\", outputx, 225);\r\n    // text(\"Duck\", outputx, 325);\r\n  } else { //evolving normally \r\n    if (cWidth > 800) {\r\n      textSize(18);\r\n\r\n      textFont(fontRegular);\r\n      textAlign(LEFT);\r\n      fill('#1B242F');\r\n      text(\"Score: \", 30, height - 30);\r\n\r\n      fill('#036367');\r\n      text(floor(population.populationLife / 3.0), 90, height - 30);\r\n\r\n\r\n      //text(, width/2-180, height-30);\r\n      textAlign(CENTER);\r\n      // text(\"Teaching Dino to play automatically using Artificial Intelligence\", width / 2, height - 50);\r\n      fill('#1B242F');\r\n      text(\"Teaching 'Dino' to play automatically using \", width / 2 - 88, height - 30);\r\n      textFont(fontBold);\r\n      fill('#036367');\r\n      text(\"Artificial Intelligence\", width / 2 + 190, height - 30);\r\n\r\n      textFont(fontRegular);\r\n      textAlign(RIGHT);\r\n      fill('#1B242F');\r\n      text(\"Gen: \", width - 55, height - 30);\r\n      fill('#036367');\r\n      text((population.gen + 1), width - 30, height - 30);\r\n    }\r\n    else {\r\n      textSize(14);\r\n\r\n      textFont(fontRegular);\r\n      textAlign(LEFT);\r\n      fill('#1B242F');\r\n      text(\"S: \", 15, height - 25);\r\n\r\n      fill('#036367');\r\n      text(floor(population.populationLife / 3.0), 30, height - 25);\r\n\r\n      //text(, width/2-180, height-30);\r\n      fill('#1B242F');\r\n      textAlign(CENTER);\r\n      // text(\"Teaching Dino to play automatically using\", width / 2, height - 50);\r\n      textFont(fontRegular);\r\n      text(\"Teaching 'Dino' to play automatically using \", width / 2, height - 50);\r\n      textFont(fontBold);\r\n      fill('#036367');\r\n      text(\"Artificial Intelligence\", width / 2, height - 30);\r\n\r\n      textFont(fontRegular);\r\n      textAlign(RIGHT);\r\n      fill('#1B242F');\r\n      text(\"G: \", width - 25, height - 25);\r\n      fill('#036367');\r\n      text((population.gen + 1), width - 15, height - 25);\r\n    }\r\n    textSize(15);\r\n    // text(\"Distace to next obstacle\", x, 18 + 44.44444);\r\n    // text(\"Height of obstacle\", x, 18 + 2 * 44.44444);\r\n    // text(\"Width of obstacle\", x, 18 + 3 * 44.44444);\r\n    // text(\"Bird height\", x, 18 + 4 * 44.44444);\r\n    // text(\"Speed\", x, 18 + 5 * 44.44444);\r\n    // text(\"Players Y position\", x, 18 + 6 * 44.44444);\r\n    // text(\"Gap between obstacles\", x, 18 + 7 * 44.44444);\r\n    // text(\"Bias\", x, 18 + 8 * 44.44444);\r\n\r\n    // textAlign(LEFT);\r\n    // text(\"Small Jump\", 820, 118);\r\n    // text(\"Big Jump\", 820, 218);\r\n    // text(\"Duck\", 820, 318);\r\n  }\r\n}\r\n\r\n\r\n//--------------------------------------------------------------------------------------------------------------------------------------------------\r\n\r\nfunction keyPressed() {\r\n  switch (keyCode) {\r\n    // case 107://speed up frame rate\r\n    //   frameSpeed += 10;\r\n    //   frameRate(frameSpeed);\r\n    //   console.log(frameSpeed);\r\n    //   break;\r\n    // case 109://slow down frame rate\r\n    //   if (frameSpeed > 10) {\r\n    //     frameSpeed -= 10;\r\n    //     frameRate(frameSpeed);\r\n    //     console.log(frameSpeed);\r\n    //   }\r\n    //   break;\r\n    // case 71://show generations 'g'\r\n    //   showBestEachGen = !showBestEachGen;\r\n    //   upToGen = 0;\r\n    //   genPlayerTemp = population.genPlayers[upToGen].cloneForReplay();\r\n    //   break;\r\n    // case 65:\r\n    //   population.saveBests();\r\n    //   break;\r\n    // case 83:\r\n    //   population.savePopulation();\r\n    //   break;\r\n    // case 78://'n' -show absolutely nothing in order to speed up computation\r\n    //   showNothing = !showNothing;\r\n    //   break;\r\n    case RIGHT_ARROW://any of the arrow keys\r\n      if (showBestEachGen) {//if showing the best player each generation then move on to the next generation\r\n        upToGen++;\r\n        if (upToGen >= population.genPlayers.length) {//if reached the current generation then exit out of the showing generations mode\r\n          upToGen = 0;\r\n        }\r\n        genPlayerTemp = population.genPlayers[upToGen].cloneForReplay();\r\n      }\r\n      break;\r\n    case LEFT_ARROW://any of the arrow keys\r\n      if (showBestEachGen) {//if showing the best player each generation then move on to the next generation\r\n        upToGen--;\r\n        if (upToGen < 0) {//if reached the current generation then exit out of the showing generations mode\r\n          upToGen = population.genPlayers.length - 1;\r\n        }\r\n        genPlayerTemp = population.genPlayers[upToGen].cloneForReplay();\r\n      }\r\n      break;\r\n  }\r\n}\r\n//---------------------------------------------------------------------------------------------------------------------------------------------------------\r\n//called every frame\r\nfunction updateObstacles() {\r\n  obstacleTimer++;\r\n  speed += speedIncrement;\r\n  if (obstacleTimer > minimumTimeBetweenObstacles + randomAddition) { //if the obstacle timer is high enough then add a new obstacle\r\n    addObstacle();\r\n  }\r\n  groundCounter++;\r\n  if (groundCounter > 10) { //every 10 frames add a ground bit\r\n    groundCounter = 0;\r\n    grounds.push(new Ground());\r\n  }\r\n\r\n  moveObstacles();//move everything\r\n  if (!showNothing) {//show everything\r\n    showObstacles();\r\n  }\r\n}\r\n\r\n//---------------------------------------------------------------------------------------------------------------------------------------------------------\r\n//moves obstacles to the left based on the speed of the game \r\nfunction moveObstacles() {\r\n  // console.log(speed);\r\n  for (var i = 0; i < obstacles.length; i++) {\r\n    obstacles[i].move(speed);\r\n    if (obstacles[i].posX < -playerXpos) {\r\n      obstacles.splice(i, 1);\r\n      i--;\r\n    }\r\n  }\r\n\r\n  for (var i = 0; i < birds.length; i++) {\r\n    birds[i].move(speed);\r\n    if (birds[i].posX < -playerXpos) {\r\n      birds.splice(i, 1);\r\n      i--;\r\n    }\r\n  }\r\n  for (var i = 0; i < grounds.length; i++) {\r\n    grounds[i].move(speed);\r\n    if (grounds[i].posX < -playerXpos) {\r\n      grounds.splice(i, 1);\r\n      i--;\r\n    }\r\n  }\r\n}\r\n//------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n//every so often add an obstacle \r\nfunction addObstacle() {\r\n  var lifespan = population.populationLife;\r\n  var tempInt;\r\n  // if (lifespan > (stage + 1) * 900) {\r\n  //   stage++;\r\n  // }\r\n  // if (stage > 3) {\r\n  //   stage = 3;\r\n  // }\r\n\r\n  // if (stage == 3) {\r\n  //   if (random(1) < 0.20) { // 20% of the time add a bird\r\n  //     tempInt = floor(random(3));\r\n  //     var temp = new Bird(tempInt);//floor(random(3)));\r\n  //     birds.push(temp);\r\n  //   } else {\r\n  //     tempInt = floor(random(3));\r\n  //     var temp = new Obstacle(tempInt);//floor(random(3)));\r\n  //     obstacles.push(temp);\r\n  //     tempInt += 3;\r\n  //   }\r\n  // }\r\n  // else if (stage == 2) {\r\n  //   tempInt = floor(random(3));\r\n  //   var temp = new Obstacle(tempInt);//floor(random(3)));\r\n  //   obstacles.push(temp);\r\n  //   tempInt += 3;\r\n  // }\r\n  // else if (stage == 1) {\r\n  //   tempInt = floor(random(2));\r\n  //   var temp = new Obstacle(tempInt);//floor(random(3)));\r\n  //   obstacles.push(temp);\r\n  //   tempInt += 3;\r\n  // }\r\n  // else {\r\n  //   tempInt = floor(random(1));\r\n  //   var temp = new Obstacle(tempInt);//floor(random(3)));\r\n  //   obstacles.push(temp);\r\n  //   tempInt += 3;\r\n  // }\r\n  if (lifespan > 1000 && random(1) < 0.15) { // 15% of the time add a bird\r\n    tempInt = floor(random(3));\r\n    var temp = new Bird(tempInt);//floor(random(3)));\r\n    birds.push(temp);\r\n  } else {//otherwise add a cactus\r\n    tempInt = floor(random(3));\r\n    var temp = new Obstacle(tempInt);//floor(random(3)));\r\n    obstacles.push(temp);\r\n    tempInt += 3;\r\n  }\r\n\r\n  obstacleHistory.push(tempInt);\r\n\r\n  randomAddition = floor(random(50));\r\n  randomAdditionHistory.push(randomAddition);\r\n  obstacleTimer = 0;\r\n}\r\n//---------------------------------------------------------------------------------------------------------------------------------------------------------\r\n//what do you think this does?\r\nfunction showObstacles() {\r\n  for (var i = 0; i < grounds.length; i++) {\r\n    grounds[i].show();\r\n  }\r\n  for (var i = 0; i < obstacles.length; i++) {\r\n    obstacles[i].show();\r\n  }\r\n\r\n  for (var i = 0; i < birds.length; i++) {\r\n    birds[i].show();\r\n  }\r\n}\r\n\r\n//-------------------------------------------------------------------------------------------------------------------------------------------\r\n//resets all the obstacles after every dino has died\r\nfunction resetObstacles() {\r\n  randomAdditionHistory = [];\r\n  obstacleHistory = [];\r\n\r\n  obstacles = [];\r\n  birds = [];\r\n  obstacleTimer = 0;\r\n  randomAddition = 0;\r\n  groundCounter = 0;\r\n  speed = 10 * speed_scl;\r\n}","class Genome {\r\n  constructor(inputs, out, crossover) {\r\n    this.genes = [];\r\n    this.nodes = [];\r\n    //set input number and output number\r\n    this.inputs = inputs;\r\n    this.outputs = out;\r\n    this.layers = 2;\r\n    this.nextNode = 0;\r\n    this.biasNode;\r\n    this.network = []; //a list of the nodes in the order that they need to be considered in the NN\r\n\r\n    if (crossover) {\r\n      return;\r\n    }\r\n\r\n    //create input nodes\r\n    for (var i = 0; i < this.inputs; i++) {\r\n      this.nodes.push(new Node(i));\r\n      this.nextNode++;\r\n      this.nodes[i].layer = 0;\r\n    }\r\n\r\n    //create output nodes\r\n    for (var i = 0; i < this.outputs; i++) {\r\n      this.nodes.push(new Node(i + this.inputs));\r\n      this.nodes[i + this.inputs].layer = 1;\r\n      this.nextNode++;\r\n    }\r\n\r\n    this.nodes.push(new Node(this.nextNode));//bias node\r\n    this.biasNode = this.nextNode;\r\n    this.nextNode++;\r\n    this.nodes[this.biasNode].layer = 0; // bias node in layer 0 (input layer)\r\n  }\r\n\r\n  fromJSON(obj) {\r\n    this.genes = [];\r\n    for (var i in obj.genes) {\r\n      var cg = obj.genes[i];\r\n      var cg1 = new connectionGene().fromJSON(cg);\r\n      this.genes.push(cg1);\r\n    }\r\n    this.nodes = [];\r\n    for (var i in obj.nodes) {\r\n      var node = new Node().fromJSON(obj.nodes[i]);\r\n      this.nodes.push(node);\r\n    }\r\n    //set input number and output number\r\n    this.inputs = obj.inputs;\r\n    this.outputs = obj.outputs;\r\n    this.layers = obj.layers;\r\n    this.nextNode = obj.nextNode;\r\n    this.biasNode = obj.biasNode;\r\n    this.network = []; //a list of the nodes in the order that they need to be considered in the NN\r\n    for (var i in obj.network) {\r\n      var node = new Node().fromJSON(obj.network[i]);\r\n      this.network.push(node);\r\n    }\r\n    return this;\r\n  }\r\n\r\n\r\n\r\n  //-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n  //returns the node with a matching number\r\n  //sometimes the nodes will not be in order\r\n  getNode(nodeNumber) {\r\n    for (var i = 0; i < this.nodes.length; i++) {\r\n      if (this.nodes[i].number == nodeNumber) {\r\n        return this.nodes[i];\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n\r\n  //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n  //adds the conenctions going out of a node to that node so that it can acess the next node during feeding forward\r\n  connectNodes() {\r\n\r\n    for (var i = 0; i < this.nodes.length; i++) {//clear the connections\r\n      this.nodes[i].outputConnections = [];\r\n    }\r\n\r\n    for (var i = 0; i < this.genes.length; i++) {//for each connectionGene \r\n      this.genes[i].fromNode.outputConnections.push(this.genes[i]);//add it to node\r\n    }\r\n  }\r\n\r\n  //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n  //feeding in input values into the NN and returning output array\r\n  feedForward(inputValues) {\r\n    //set the outputs of the input nodes\r\n    for (var i = 0; i < this.inputs; i++) {\r\n      this.nodes[i].outputValue = inputValues[i];\r\n    }\r\n    this.nodes[this.biasNode].outputValue = 1;//output of bias is 1\r\n\r\n    for (var i = 0; i < this.network.length; i++) {//for each node in the network engage it(see node class for what this does)\r\n      this.network[i].engage();\r\n    }\r\n\r\n    //the outputs are nodes[inputs] to nodes [inputs+outputs-1]\r\n    var outs = [];\r\n    for (var i = 0; i < this.outputs; i++) {\r\n      outs[i] = this.nodes[this.inputs + i].outputValue;\r\n    }\r\n\r\n    for (var i = 0; i < this.nodes.length; i++) {//reset all the nodes for the next feed forward\r\n      this.nodes[i].inputSum = 0;\r\n    }\r\n\r\n    return outs;\r\n  }\r\n\r\n  //----------------------------------------------------------------------------------------------------------------------------------------\r\n  //sets up the NN as a list of nodes in order to be engaged \r\n\r\n  generateNetwork() {\r\n    this.connectNodes();\r\n    this.network = [];\r\n    //for each layer add the node in that layer, since layers cannot connect to themselves there is no need to order the nodes within a layer\r\n\r\n    for (var l = 0; l < this.layers; l++) {//for each layer\r\n      for (var i = 0; i < this.nodes.length; i++) {//for each node\r\n        if (this.nodes[i].layer == l) {//if that node is in that layer\r\n          this.network.push(this.nodes[i]);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  //-----------------------------------------------------------------------------------------------------------------------------------------\r\n  //mutate the NN by adding a new node\r\n  //it does this by picking a random connection and disabling it then 2 new connections are added \r\n  //1 between the input node of the disabled connection and the new node\r\n  //and the other between the new node and the output of the disabled connection\r\n  addNode(innovationHistory) {\r\n    //pick a random connection to create a node between\r\n    if (this.genes.length == 0) {\r\n      this.addConnection(innovationHistory);\r\n      return;\r\n    }\r\n    var randomConnection = 0;\r\n    randomConnection = Math.floor(Math.random() * this.genes.length);\r\n\r\n    while (this.genes[randomConnection].fromNode == this.nodes[this.biasNode] && this.genes.length != 1) {//dont disconnect bias\r\n      randomConnection = Math.floor(Math.random() * this.genes.length);\r\n    }\r\n\r\n    this.genes[randomConnection].enabled = false;//disable it\r\n\r\n    var newNodeNo = this.nextNode;\r\n    this.nodes.push(new Node(newNodeNo));\r\n    this.nextNode++;\r\n    //add a new connection to the new node with a weight of 1\r\n    var connectionInnovationNumber = this.getInnovationNumber(innovationHistory, this.genes[randomConnection].fromNode, this.getNode(newNodeNo));\r\n    this.genes.push(new connectionGene(this.genes[randomConnection].fromNode, this.getNode(newNodeNo), 1, connectionInnovationNumber));\r\n\r\n\r\n    connectionInnovationNumber = this.getInnovationNumber(innovationHistory, this.getNode(newNodeNo), this.genes[randomConnection].toNode);\r\n    //add a new connection from the new node with a weight the same as the disabled connection\r\n    this.genes.push(new connectionGene(this.getNode(newNodeNo), this.genes[randomConnection].toNode, this.genes[randomConnection].weight, connectionInnovationNumber));\r\n    this.getNode(newNodeNo).layer = this.genes[randomConnection].fromNode.layer + 1;\r\n\r\n\r\n    connectionInnovationNumber = this.getInnovationNumber(innovationHistory, this.nodes[this.biasNode], this.getNode(newNodeNo));\r\n    //connect the bias to the new node with a weight of 0 \r\n    this.genes.push(new connectionGene(this.nodes[this.biasNode], this.getNode(newNodeNo), 0, connectionInnovationNumber));\r\n\r\n    //if the layer of the new node is equal to the layer of the output node of the old connection then a new layer needs to be created\r\n    //more accurately the layer numbers of all layers equal to or greater than this new node need to be incrimented\r\n    if (this.getNode(newNodeNo).layer == this.genes[randomConnection].toNode.layer) {\r\n      for (var i = 0; i < this.nodes.length - 1; i++) {//dont include this newest node\r\n        if (this.nodes[i].layer >= this.getNode(newNodeNo).layer) {\r\n          this.nodes[i].layer++;\r\n        }\r\n      }\r\n      this.layers++;\r\n    }\r\n    this.connectNodes();\r\n  }\r\n\r\n  //------------------------------------------------------------------------------------------------------------------\r\n  //adds a connection between 2 nodes which aren't currently connected\r\n  addConnection(innovationHistory) {\r\n    //cannot add a connection to a fully connected network\r\n    if (this.fullyConnected()) {\r\n      console.log(\"connection failed\");\r\n      return;\r\n    }\r\n\r\n\r\n    //get random nodes\r\n    var randomNode1 = floor(random(this.nodes.length));\r\n    var randomNode2 = floor(random(this.nodes.length));\r\n    while (this.randomConnectionNodesAreShit(randomNode1, randomNode2)) {//while the random nodes are no good\r\n      //get new ones\r\n      randomNode1 = floor(random(this.nodes.length));\r\n      randomNode2 = floor(random(this.nodes.length));\r\n    }\r\n    var temp;\r\n    if (this.nodes[randomNode1].layer > this.nodes[randomNode2].layer) {//if the first random node is after the second then switch\r\n      temp = randomNode2;\r\n      randomNode2 = randomNode1;\r\n      randomNode1 = temp;\r\n    }\r\n\r\n    //get the innovation number of the connection\r\n    //this will be a new number if no identical genome has mutated in the same way \r\n    var connectionInnovationNumber = this.getInnovationNumber(innovationHistory, this.nodes[randomNode1], this.nodes[randomNode2]);\r\n    //add the connection with a random array\r\n\r\n    this.genes.push(new connectionGene(this.nodes[randomNode1], this.nodes[randomNode2], random(-1, 1), connectionInnovationNumber));//changed this so if error here\r\n    this.connectNodes();\r\n  }\r\n  //-------------------------------------------------------------------------------------------------------------------------------------------\r\n  randomConnectionNodesAreShit(r1, r2) {\r\n    if (this.nodes[r1].layer == this.nodes[r2].layer) {\r\n      return true; // if the nodes are in the same layer\r\n    }\r\n    if (this.nodes[r1].isConnectedTo(this.nodes[r2])) {\r\n      return true; //if the nodes are already connected\r\n    }\r\n\r\n\r\n\r\n    return false;\r\n  }\r\n\r\n  //-------------------------------------------------------------------------------------------------------------------------------------------\r\n  //returns the innovation number for the new mutation\r\n  //if this mutation has never been seen before then it will be given a new unique innovation number\r\n  //if this mutation matches a previous mutation then it will be given the same innovation number as the previous one\r\n  getInnovationNumber(innovationHistory, from, to) {\r\n    var isNew = true;\r\n    var connectionInnovationNumber = nextConnectionNo;\r\n    for (var i = 0; i < innovationHistory.length; i++) {//for each previous mutation\r\n      if (innovationHistory[i].matches(this, from, to)) {//if match found\r\n        isNew = false;//its not a new mutation\r\n        connectionInnovationNumber = innovationHistory[i].innovationNumber; //set the innovation number as the innovation number of the match\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (isNew) {//if the mutation is new then create an arrayList of integers representing the current state of the genome\r\n      var innoNumbers = [];\r\n      for (var i = 0; i < this.genes.length; i++) {//set the innovation numbers\r\n        innoNumbers.push(this.genes[i].innovationNo);\r\n      }\r\n\r\n      //then add this mutation to the innovationHistory \r\n      innovationHistory.push(new connectionHistory(from.number, to.number, connectionInnovationNumber, innoNumbers));\r\n      nextConnectionNo++;\r\n    }\r\n    return connectionInnovationNumber;\r\n  }\r\n  //----------------------------------------------------------------------------------------------------------------------------------------\r\n\r\n  //returns whether the network is fully connected or not\r\n  fullyConnected() {\r\n    var maxConnections = 0;\r\n    var nodesInLayers = [];//array which stored the amount of nodes in each layer\r\n\r\n    //populate array\r\n    for (var i = 0; i < this.nodes.length; i++) {\r\n      if (!nodesInLayers[this.nodes[i].layer]) {\r\n        nodesInLayers[this.nodes[i].layer] = 0;\r\n      }\r\n      nodesInLayers[this.nodes[i].layer] += 1;\r\n    }\r\n\r\n    //for each layer the maximum amount of connections is the number in this layer * the number of nodes infront of it\r\n    //so lets add the max for each layer together and then we will get the maximum amount of connections in the network\r\n    for (var i = 0; i < this.layers - 1; i++) {\r\n      var nodesInFront = 0;\r\n      for (var j = i + 1; j < this.layers; j++) {//for each layer infront of this layer\r\n        nodesInFront += nodesInLayers[j];//add up nodes\r\n      }\r\n\r\n      maxConnections += nodesInLayers[i] * nodesInFront;\r\n    }\r\n\r\n    if (maxConnections == this.genes.length) {//if the number of connections is equal to the max number of connections possible then it is full\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n\r\n  //-------------------------------------------------------------------------------------------------------------------------------\r\n  //mutates the genome\r\n  mutate(innovationHistory) {\r\n    if (this.genes.length == 0) {\r\n      this.addConnection(innovationHistory);\r\n    }\r\n\r\n    var rand1 = random(1);\r\n    if (rand1 < 0.8) { // 80% of the time mutate weights\r\n      for (var i = 0; i < this.genes.length; i++) {\r\n        this.genes[i].mutateWeight();\r\n      }\r\n    }\r\n    //20% of the time add a new connection\r\n    var rand2 = random(1);\r\n    if (rand2 < 0.08) {\r\n      this.addConnection(innovationHistory);\r\n    }\r\n\r\n\r\n    //2% of the time add a node\r\n    var rand3 = random(1);\r\n    if (rand3 < 0.02) {\r\n      this.addNode(innovationHistory);\r\n    }\r\n  }\r\n\r\n  //---------------------------------------------------------------------------------------------------------------------------------\r\n  //called when this Genome is better that the other parent\r\n  crossover(parent2) {\r\n    var child = new Genome(this.inputs, this.outputs, true);\r\n    child.genes = [];\r\n    child.nodes = [];\r\n    child.layers = this.layers;\r\n    child.nextNode = this.nextNode;\r\n    child.biasNode = this.biasNode;\r\n    var childGenes = [];//list of genes to be inherrited form the parents\r\n    var isEnabled = [];\r\n    //all inherrited genes\r\n    for (var i = 0; i < this.genes.length; i++) {\r\n      var setEnabled = true;//is this node in the chlid going to be enabled\r\n\r\n      var parent2gene = this.matchingGene(parent2, this.genes[i].innovationNo);\r\n      if (parent2gene != -1) {//if the genes match\r\n        if (!this.genes[i].enabled || !parent2.genes[parent2gene].enabled) {//if either of the matching genes are disabled\r\n\r\n          if (random(1) < 0.75) {//75% of the time disabel the childs gene\r\n            setEnabled = false;\r\n          }\r\n        }\r\n        var rand = random(1);\r\n        if (rand < 0.5) {\r\n          childGenes.push(this.genes[i]);\r\n\r\n          //get gene from this fucker\r\n        } else {\r\n          //get gene from parent2\r\n          childGenes.push(parent2.genes[parent2gene]);\r\n        }\r\n      } else {//disjoint or excess gene\r\n        childGenes.push(this.genes[i]);\r\n        setEnabled = this.genes[i].enabled;\r\n      }\r\n      isEnabled.push(setEnabled);\r\n    }\r\n\r\n\r\n    //since all excess and disjoint genes are inherrited from the more fit parent (this Genome) the childs structure is no different from this parent | with exception of dormant connections being enabled but this wont effect nodes\r\n    //so all the nodes can be inherrited from this parent\r\n    for (var i = 0; i < this.nodes.length; i++) {\r\n      child.nodes.push(this.nodes[i].clone());\r\n    }\r\n\r\n    //clone all the connections so that they connect the childs new nodes\r\n\r\n    for (var i = 0; i < childGenes.length; i++) {\r\n      child.genes.push(childGenes[i].clone(child.getNode(childGenes[i].fromNode.number),\r\n        child.getNode(childGenes[i].toNode.number)));\r\n      child.genes[i].enabled = isEnabled[i];\r\n    }\r\n\r\n    child.connectNodes();\r\n    return child;\r\n  }\r\n\r\n  //----------------------------------------------------------------------------------------------------------------------------------------\r\n  //returns whether or not there is a gene matching the input innovation number  in the input genome\r\n  matchingGene(parent2, innovationNumber) {\r\n    for (var i = 0; i < parent2.genes.length; i++) {\r\n      if (parent2.genes[i].innovationNo == innovationNumber) {\r\n        return i;\r\n      }\r\n    }\r\n    return -1; //no matching gene found\r\n  }\r\n  //----------------------------------------------------------------------------------------------------------------------------------------\r\n  //prints out info about the genome to the console \r\n  printGenome() {\r\n    console.log(\"Prvar genome  layers:\" + this.layers);\r\n    console.log(\"bias node: \" + this.biasNode);\r\n    console.log(\"this.nodes\");\r\n    for (var i = 0; i < this.nodes.length; i++) {\r\n      console.log(this.nodes[i].number + \",\");\r\n    }\r\n    console.log(\"Genes\");\r\n    for (var i = 0; i < this.genes.length; i++) {//for each connectionGene \r\n      console.log(\"gene \" + this.genes[i].innovationNo + \"From node \" + this.genes[i].fromNode.number + \"To node \" + this.genes[i].toNode.number +\r\n        \"is enabled \" + this.genes[i].enabled + \"from layer \" + this.genes[i].fromNode.layer + \"to layer \" + this.genes[i].toNode.layer + \"weight: \" + this.genes[i].weight);\r\n    }\r\n\r\n    console.log();\r\n  }\r\n\r\n  //----------------------------------------------------------------------------------------------------------------------------------------\r\n  //returns a copy of this genome\r\n  clone() {\r\n\r\n    var clone = new Genome(this.inputs, this.outputs, true);\r\n\r\n    for (var i = 0; i < this.nodes.length; i++) {//copy nodes\r\n      clone.nodes.push(this.nodes[i].clone());\r\n    }\r\n\r\n    //copy all the connections so that they connect the clone new nodes\r\n\r\n    for (var i = 0; i < this.genes.length; i++) {//copy genes\r\n      clone.genes.push(this.genes[i].clone(clone.getNode(this.genes[i].fromNode.number), clone.getNode(this.genes[i].toNode.number)));\r\n    }\r\n\r\n    clone.layers = this.layers;\r\n    clone.nextNode = this.nextNode;\r\n    clone.biasNode = this.biasNode;\r\n    clone.connectNodes();\r\n\r\n    return clone;\r\n  }\r\n\r\n  cloneForJSON() {\r\n\r\n    var clone = new Genome(this.inputs, this.outputs, true);\r\n\r\n    for (var i = 0; i < this.nodes.length; i++) {//copy nodes\r\n      clone.nodes.push(this.nodes[i].clone());\r\n    }\r\n\r\n    //copy all the connections so that they connect the clone new nodes\r\n\r\n    for (var i = 0; i < this.genes.length; i++) {//copy genes\r\n      clone.genes.push(this.genes[i].cloneForJSON(clone.getNode(this.genes[i].fromNode.number), clone.getNode(this.genes[i].toNode.number)));\r\n    }\r\n\r\n    clone.layers = this.layers;\r\n    clone.nextNode = this.nextNode;\r\n    clone.biasNode = this.biasNode;\r\n    // clone.connectNodes();\r\n\r\n    return clone;\r\n  }\r\n  //----------------------------------------------------------------------------------------------------------------------------------------\r\n  //draw the genome on the screen\r\n  drawGenome(startX, startY, w, h) {\r\n    //i know its ugly but it works (and is not that important) so I'm not going to mess with it\r\n    var allNodes = [];\r\n    var nodePoses = [];\r\n    var nodeNumbers = [];\r\n    var nodeColors = [];\r\n\r\n    //get the positions on the screen that each node is supposed to be in\r\n\r\n\r\n    //split the nodes into layers\r\n    for (var i = 0; i < this.layers; i++) {\r\n      var temp = [];\r\n      for (var j = 0; j < this.nodes.length; j++) {//for each node \r\n        if (this.nodes[j].layer == i) {//check if it is in this layer\r\n          temp.push(this.nodes[j]); //add it to this layer\r\n        }\r\n      }\r\n      allNodes.push(temp);//add this layer to all nodes\r\n    }\r\n\r\n    //for each layer add the position of the node on the screen to the node posses arraylist\r\n    for (var i = 0; i < this.layers; i++) {\r\n      fill(255, 0, 0);\r\n      var x = startX + float(i * w) / float(this.layers - 1.0);\r\n      for (var j = 0; j < allNodes[i].length; j++) {//for the position in the layer\r\n        var y = startY + float((j + 1.0) * h) / float(allNodes[i].length + 1.0);\r\n        nodePoses.push(createVector(x, y));\r\n        nodeNumbers.push(allNodes[i][j].number);\r\n        if (i == 0) {\r\n          nodeColors.push(color(207, 254, 207));\r\n        }\r\n        else if (i == this.layers - 1) {\r\n          nodeColors.push(color(255, 254, 160));\r\n        }\r\n        else {\r\n          nodeColors.push(color(206, 237, 254));\r\n        }\r\n        if (i == this.layers - 1) {\r\n          // console.log(i + \" \" + j + \" \" + x + \" \" + y);\r\n        }\r\n      }\r\n    }\r\n\r\n    //draw connections \r\n    stroke(0);\r\n    strokeWeight(2);\r\n    for (var i = 0; i < this.genes.length; i++) {\r\n      if (this.genes[i].enabled) {\r\n        stroke(0);\r\n      } else {\r\n        stroke(100);\r\n      }\r\n      var from;\r\n      var to;\r\n      from = nodePoses[nodeNumbers.indexOf(this.genes[i].fromNode.number)];\r\n      to = nodePoses[nodeNumbers.indexOf(this.genes[i].toNode.number)];\r\n      if (this.genes[i].weight > 0) {\r\n        stroke(71, 120, 82);\r\n      } else {\r\n        stroke(255, 0, 0);\r\n      }\r\n      strokeWeight(map(abs(this.genes[i].weight * scl), 0, 1, 0, 5));\r\n      line(from.x, from.y, to.x, to.y);\r\n    }\r\n\r\n    //draw nodes last so they appear ontop of the connection lines\r\n    for (var i = 0; i < nodePoses.length; i++) {\r\n      fill(nodeColors[i]);\r\n      stroke(0);\r\n      strokeWeight(1);\r\n      ellipse(nodePoses[i].x, nodePoses[i].y, 20 * scl, 20 * scl);\r\n      // textSize(10);\r\n      // fill(0);\r\n      // textAlign(CENTER, CENTER);\r\n\r\n\r\n      // text(nodeNumbers[i], nodePoses[i].x, nodePoses[i].y);\r\n    }\r\n  }\r\n}","//this class is useless it just shows some dots on the ground\r\n\r\nclass Ground {\r\n  constructor() {\r\n    this.posX = width;\r\n    this.posY = height - floor(random(groundHeight - 20 * scl, groundHeight + 30 * scl));\r\n    this.w = floor(random(1, 10));\r\n  }\r\n\r\n  show() {\r\n    stroke(0);\r\n    strokeWeight(3);\r\n    line(this.posX, this.posY, this.posX + this.w, this.posY);\r\n  }\r\n  move(speed) {\r\n    this.posX -= speed;\r\n  }\r\n}","class Node {\r\n  //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n  //constructor\r\n  constructor(no) {\r\n    this.number = no;\r\n    this.inputSum = 0;//current sum i.e. before activation\r\n    this.outputValue = 0; //after activation function is applied\r\n    this.outputConnections = [];\r\n    this.layer = 0;\r\n    this.drawPos = new createVector();\r\n  }\r\n  fromJSON(obj) {\r\n    this.number = obj.number;\r\n    this.inputSum = obj.inputSum;//current sum i.e. before activation\r\n    this.outputValue = obj.outputValue; //after activation function is applied\r\n    this.outputConnections = [];\r\n    this.layer = obj.layer;\r\n    this.drawPos = new createVector();\r\n    return this;\r\n  }\r\n\r\n  //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n  //the node sends its output to the inputs of the nodes its connected to\r\n  engage() {\r\n    if (this.layer != 0) {//no sigmoid for the inputs and bias\r\n      this.outputValue = this.sigmoid(this.inputSum);\r\n    }\r\n\r\n    for (var i = 0; i < this.outputConnections.length; i++) {//for each connection\r\n      if (this.outputConnections[i].enabled) {//dont do shit if not enabled\r\n        this.outputConnections[i].toNode.inputSum += this.outputConnections[i].weight * this.outputValue;\r\n        //add the weighted output to the sum of the inputs of whatever node this node is connected to\r\n      }\r\n    }\r\n  }\r\n  //----------------------------------------------------------------------------------------------------------------------------------------\r\n  //not used\r\n  stepFunction(x) {\r\n    if (x < 0) {\r\n      return 0;\r\n    } else {\r\n      return 1;\r\n    }\r\n  }\r\n  //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n  //sigmoid activation function\r\n  sigmoid(x) {\r\n    var y = 1 / (1 + pow(Math.E, -4.9 * x));\r\n    // console.log(\"sigmoid x: \" + x + \" y: \" + y);\r\n    return y;\r\n  }\r\n  //----------------------------------------------------------------------------------------------------------------------------------------------------------\r\n  //returns whether this node connected to the parameter node\r\n  //used when adding a new connection \r\n  isConnectedTo(node) {\r\n    if (node.layer == this.layer) {//nodes in the same layer cannot be connected\r\n      return false;\r\n    }\r\n\r\n    //you get it\r\n    if (node.layer < this.layer) {\r\n      for (var i = 0; i < node.outputConnections.length; i++) {\r\n        if (node.outputConnections[i].toNode == this) {\r\n          return true;\r\n        }\r\n      }\r\n    } else {\r\n      for (var i = 0; i < this.outputConnections.length; i++) {\r\n        if (this.outputConnections[i].toNode == node) {\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n  //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n  //returns a copy of this node\r\n  clone() {\r\n    var clone = new Node(this.number);\r\n    clone.layer = this.layer;\r\n    return clone;\r\n  }\r\n\r\n  cloneForJSON() {\r\n    var clone = new Node(this.number);\r\n    clone.number = this.number;\r\n    clone.inputSum = this.inputSum;//current sum i.e. before activation\r\n    clone.outputValue = this.outputValue; //after activation function is applied\r\n    clone.outputConnections = []; // reason of everything : (\r\n    clone.layer = this.layer;\r\n    clone.drawPos = new createVector();\r\n    return clone;\r\n  }\r\n\r\n}","class Obstacle {\r\n\r\n  //------------------------------------------------------------------------------------------------------------------------------------------------------\r\n  //constructor\r\n  constructor(t) {\r\n    this.w;\r\n    this.h;\r\n    this.posX = width;\r\n    this.type = t;\r\n    switch (this.type) {\r\n      case 0://small cactus\r\n        this.w = 40 * scl;\r\n        this.h = 80 * scl;\r\n        break;\r\n      case 1://big cactus\r\n        this.w = 60 * scl;\r\n        this.h = 120 * scl;\r\n        break;\r\n      case 2://small cacti\r\n        this.w = 120 * scl;\r\n        this.h = 80 * scl;\r\n        break;\r\n    }\r\n  }\r\n\r\n  //------------------------------------------------------------------------------------------------------------------------------------------------------\r\n  //show the cactus\r\n  show() {\r\n    fill(0);\r\n    rectMode(CENTER);\r\n    switch (this.type) {\r\n      case 0:\r\n        image(smallCactus, this.posX - smallCactus.width / 2 * scl, height - groundHeight - smallCactus.height * scl, this.w, this.h);\r\n        break;\r\n      case 1:\r\n        image(bigCactus, this.posX - bigCactus.width / 2 * scl, height - groundHeight - bigCactus.height * scl, this.w, this.h);\r\n        break;\r\n      case 2:\r\n        image(manySmallCactus, this.posX - manySmallCactus.width / 2 * scl, height - groundHeight - manySmallCactus.height * scl, this.w, this.h);\r\n        break;\r\n    }\r\n  }\r\n  //------------------------------------------------------------------------------------------------------------------------------------------------------\r\n  // move the obstacle\r\n  move(speed) {\r\n    this.posX -= speed;\r\n  }\r\n  //------------------------------------------------------------------------------------------------------------------------------------------------------\r\n  //returns whether or not the player collides with this obstacle\r\n  collided(playerX, playerY, playerWidth, playerHeight) {\r\n\r\n    var playerLeft = playerX - playerWidth / 2;\r\n    var playerRight = playerX + playerWidth / 2;\r\n    var thisLeft = this.posX - this.w / 2;\r\n    var thisRight = this.posX + this.w / 2;\r\n\r\n    if ((playerLeft <= thisRight && playerRight >= thisLeft) || (thisLeft <= playerRight && thisRight >= playerLeft)) {\r\n      var playerDown = playerY - playerHeight / 2;\r\n      var thisUp = this.h;\r\n      if (playerDown <= thisUp) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n}","class Player {\r\n  //---------------------------------------------------------------------------------------------------------------------------------------------------------\r\n  //constructor\r\n\r\n  constructor() {\r\n    this.fitness = 0;\r\n    this.brain;\r\n    this.replay = false;\r\n\r\n    this.unadjustedFitness;\r\n    this.lifespan = 0;//how long the player lived for fitness\r\n    this.bestScore = 0;//stores the score achieved used for replay\r\n    this.dead;\r\n    this.score = 0;\r\n    this.gen = 0;\r\n\r\n    this.genomeInputs = 7;\r\n    this.genomeOutputs = 3;\r\n\r\n    this.vision = [];//the input array fed into the neuralNet \r\n    this.decision = []; //the out put of the NN \r\n    this.posY = 0;\r\n    this.velY = 0;\r\n    this.gravity = playerDefaultGravity;\r\n    this.runCount = -5;\r\n    this.size = playerSize;\r\n\r\n    this.replayObstacles = [];\r\n    this.replayBirds = [];\r\n    this.localObstacleHistory = [];\r\n    this.localRandomAdditionHistory = [];\r\n    this.historyCounter = 0;\r\n    this.localObstacleTimer = 0;\r\n    this.localSpeed = default_speed;\r\n    this.localSpeedIncrement = speedIncrement;\r\n    this.localRandomAddition = 0;\r\n\r\n    this.duck = false;\r\n    this.brain = new Genome(this.genomeInputs, this.genomeOutputs);\r\n  }\r\n\r\n  fromJSON(obj) {\r\n    this.fitness = obj.fitness;\r\n    this.replay = obj.replay;\r\n\r\n    this.unadjustedFitness = obj.unadjustedFitness;\r\n    this.lifespan = obj.lifespan;//how long the player lived for fitness\r\n    this.bestScore = obj.bestScore;//stores the score achieved used for replay\r\n    this.dead = obj.dead;\r\n    this.score = obj.score;\r\n    this.gen = obj.gen;\r\n\r\n    this.genomeInputs = obj.genomeInputs;\r\n    this.genomeOutputs = obj.genomeOutputs;\r\n\r\n    arrayCopy(obj.vision, this.vision)//the input array fed into the neuralNet \r\n    arrayCopy(obj.decision, this.decision); //the out put of the NN \r\n    this.posY = obj.posY;\r\n    this.velY = obj.velY;\r\n    this.gravity = obj.gravity;\r\n    this.runCount = obj.gravity;\r\n    this.size = obj.size;\r\n\r\n    arrayCopy(obj.replayObstacles, this.replayObstacles);\r\n    arrayCopy(obj.replayBirds, this.replayBirds);\r\n    arrayCopy(obj.localObstacleHistory, this.localObstacleHistory);\r\n    arrayCopy(obj.localRandomAdditionHistory, this.localRandomAdditionHistory);\r\n    this.historyCounter = obj.historyCounter;\r\n    this.localObstacleTimer = obj.localObstacleTimer;\r\n    this.localSpeed = obj.localSpeed;\r\n    this.localSpeedIncrement = obj.localSpeedIncrement;\r\n    this.localRandomAddition = obj.localRandomAddition;\r\n\r\n    this.duck = obj.duck;\r\n    this.brain = new Genome().fromJSON(obj.brain);\r\n    return this;\r\n  }\r\n\r\n  //---------------------------------------------------------------------------------------------------------------------------------------------------------\r\n  //show the dino\r\n  show() {\r\n    if (this.duck && this.posY == 0) {\r\n      if (this.runCount < 0) {\r\n\r\n        image(dinoDuck, playerXpos - dinoDuck.width / 2 * scl, height - groundHeight - (this.posY + dinoDuck.height * scl), dinoDuck.width * scl, dinoDuck.height * scl);\r\n      } else {\r\n\r\n        image(dinoDuck1, playerXpos - dinoDuck1.width / 2 * scl, height - groundHeight - (this.posY + dinoDuck1.height * scl), dinoDuck1.width * scl, dinoDuck1.height * scl);\r\n      }\r\n    } else\r\n      if (this.posY == 0) {\r\n        if (this.runCount < 0) {\r\n          image(dinoRun1, playerXpos - dinoRun1.width / 2 * scl, height - groundHeight - (this.posY + dinoRun1.height * scl), dinoRun1.width * scl, dinoRun1.height * scl);\r\n        } else {\r\n          image(dinoRun2, playerXpos - dinoRun2.width / 2 * scl, height - groundHeight - (this.posY + dinoRun2.height * scl), dinoRun2.width * scl, dinoRun2.height * scl);\r\n        }\r\n      } else {\r\n        image(dinoJump, playerXpos - dinoJump.width / 2 * scl, height - groundHeight - (this.posY + dinoJump.height * scl), dinoJump.width * scl, dinoJump.height * scl);\r\n      }\r\n    this.runCount++;\r\n    if (this.runCount > 5) {\r\n      this.runCount = -5;\r\n    }\r\n  }\r\n  //---------------------------------------------------------------------------------------------------------------------------------------------------------\r\n\r\n  incrementCounters() {\r\n    this.lifespan++;\r\n    if (this.lifespan % 3 == 0) {\r\n      this.score += 1;\r\n    }\r\n  }\r\n\r\n\r\n  //---------------------------------------------------------------------------------------------------------------------------------------------------------\r\n  //checks for collisions and if this is a replay move all the obstacles\r\n  move() {\r\n    this.posY += this.velY;\r\n    if (this.posY > 0) {\r\n      this.velY -= this.gravity;\r\n    } else {\r\n      this.velY = 0;\r\n      this.posY = 0;\r\n    }\r\n\r\n    if (!this.replay) {\r\n\r\n      for (var i = 0; i < obstacles.length; i++) {\r\n        if (this.posY == 0) {\r\n          if (obstacles[i].collided(playerXpos, this.posY + dinoRun1.height / 2 * scl, dinoRun1.width * 0.5 * scl, dinoRun1.height * scl)) {\r\n            this.dead = true;\r\n          }\r\n        } else {\r\n          if (obstacles[i].collided(playerXpos, this.posY + dinoJump.height / 2 * scl, dinoJump.width * 0.5 * scl, dinoJump.height * scl)) {\r\n            this.dead = true;\r\n          }\r\n        }\r\n\r\n      }\r\n\r\n      for (var i = 0; i < birds.length; i++) {\r\n        if (this.duck && this.posY == 0) {\r\n          if (birds[i].collided(playerXpos, this.posY + dinoDuck.height / 2 * scl, dinoDuck.width * 0.8 * scl, dinoDuck.height * scl)) {\r\n            this.dead = true;\r\n          }\r\n        } else {\r\n          if (birds[i].collided(playerXpos, this.posY + dinoRun1.height / 2 * scl, dinoRun1.width * 0.5 * scl, dinoRun1.height * scl)) {\r\n            this.dead = true;\r\n          }\r\n        }\r\n      }\r\n    } else {//if replayign then move local obstacles\r\n      for (var i = 0; i < this.replayObstacles.length; i++) {\r\n        if (this.posY == 0) {\r\n          if (this.replayObstacles[i].collided(playerXpos, this.posY + dinoRun1.height / 2 * scl, dinoRun1.width * 0.5 * scl, dinoRun1.height * scl)) {\r\n            this.dead = true;\r\n          }\r\n        } else {\r\n          if (this.replayObstacles[i].collided(playerXpos, this.posY + dinoJump.height / 2 * scl, dinoJump.width * 0.5 * scl, dinoRun1.height * scl)) {\r\n            this.dead = true;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n\r\n    for (var i = 0; i < this.replayBirds.length; i++) {\r\n      if (this.duck && this.posY == 0) {\r\n        if (this.replayBirds[i].collided(playerXpos, this.posY + dinoDuck.height / 2 * scl, dinoDuck.width * 0.8 * scl, dinoDuck.height * scl)) {\r\n          this.dead = true;\r\n        }\r\n      } else {\r\n        if (this.replayBirds[i].collided(playerXpos, this.posY + dinoRun1.height / 2 * scl, dinoRun1.width * 0.5 * scl, dinoRun1.height * scl)) {\r\n          this.dead = true;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n\r\n  //---------------------------------------------------------------------------------------------------------------------------------------------------------\r\n  //what could this do????\r\n  jump(bigJump) {\r\n    // console.log(this.decision);\r\n    if (this.posY == 0) {\r\n      if (bigJump) {\r\n        this.gravity = bigJumpGravity;\r\n        this.velY = highJumpY;\r\n      } else {\r\n        this.gravity = smallJumpGravity;\r\n        this.velY = lowJumpY;\r\n      }\r\n    }\r\n  }\r\n\r\n  //---------------------------------------------------------------------------------------------------------------------------------------------------------\r\n  //if parameter is true and is in the air increase gravity\r\n  ducking(isDucking) {\r\n    if (this.posY != 0 && isDucking) {\r\n      this.gravity = duckGravity;\r\n    }\r\n    this.duck = isDucking;\r\n  }\r\n\r\n  //---------------------------------------------------------------------------------------------------------------------------------------------------------\r\n  //called every frame\r\n  update() {\r\n    this.incrementCounters();\r\n    this.move();\r\n  }\r\n  //----------------------------------------------------------------------------------------------------------------------------------------------------------\r\n  //get inputs for Neural network\r\n  look() {\r\n    if (!this.replay) {\r\n      var temp = 0;\r\n      var min = 10000;\r\n      var minIndex = -1;\r\n      var berd = false;\r\n      for (var i = 0; i < obstacles.length; i++) {\r\n        if (obstacles[i].posX + obstacles[i].w / 2 - (playerXpos - dinoRun1.width / 2 * scl) < min && obstacles[i].posX + obstacles[i].w / 2 - (playerXpos - dinoRun1.width / 2 * scl) > 0) {\r\n          //if the distance between the left of the player and the right of the obstacle is the least\r\n          min = obstacles[i].posX + obstacles[i].w / 2 - (playerXpos - dinoRun1.width / 2 * scl);\r\n          minIndex = i;\r\n        }\r\n      }\r\n\r\n      for (var i = 0; i < birds.length; i++) {\r\n        if (birds[i].posX + birds[i].w / 2 - (playerXpos - dinoRun1.width / 2 * scl) < min && birds[i].posX + birds[i].w / 2 - (playerXpos - dinoRun1.width / 2 * scl) > 0) {//if the distance between the left of the player and the right of the obstacle is the least\r\n          min = birds[i].posX + birds[i].w / 2 - (playerXpos - dinoRun1.width / 2 * scl);\r\n          minIndex = i;\r\n          berd = true;\r\n        }\r\n      }\r\n      this.vision[4] = speed;\r\n      this.vision[5] = this.posY;\r\n\r\n\r\n      if (minIndex == -1) {//if there are no obstacles\r\n        this.vision[0] = 0;\r\n        this.vision[1] = 0;\r\n        this.vision[2] = 0;\r\n        this.vision[3] = 0;\r\n        this.vision[6] = 0;\r\n      } else {\r\n\r\n        this.vision[0] = 1.0 / (min / 10.0); //distance to next obstacle\r\n        if (berd) {\r\n          this.vision[1] = birds[minIndex].h; //height of obstacle\r\n          this.vision[2] = birds[minIndex].w; //width of obstacle\r\n          if (birds[minIndex].typeOfBird == 0) {\r\n            this.vision[3] = 0; // bird height\r\n          } else {\r\n            this.vision[3] = birds[minIndex].posY; // bird height\r\n          }\r\n        } else {\r\n          this.vision[1] = obstacles[minIndex].h; // height of next obstacle\r\n          this.vision[2] = obstacles[minIndex].w; // width of next obstacle\r\n          this.vision[3] = 0; //bird height\r\n        }\r\n\r\n\r\n\r\n\r\n        //vision 6 is the gap between the this obstacle and the next one\r\n        var bestIndex = minIndex;\r\n        var closestDist = min;\r\n        min = 10000;\r\n        minIndex = -1;\r\n        for (var i = 0; i < obstacles.length; i++) {\r\n          if ((berd || i != bestIndex) && obstacles[i].posX + obstacles[i].w / 2 - (playerXpos - dinoRun1.width / 2 * scl) < min && obstacles[i].posX + obstacles[i].w / 2 - (playerXpos - dinoRun1.width / 2 * scl) > 0) {//if the distance between the left of the player and the right of the obstacle is the least\r\n            min = obstacles[i].posX + obstacles[i].w / 2 - (playerXpos - dinoRun1.width / 2 * scl);\r\n            minIndex = i;\r\n          }\r\n        }\r\n\r\n        for (var i = 0; i < birds.length; i++) {\r\n          if ((!berd || i != bestIndex) && birds[i].posX + birds[i].w / 2 - (playerXpos - dinoRun1.width / 2 * scl) < min && birds[i].posX + birds[i].w / 2 - (playerXpos - dinoRun1.width / 2 * scl) > 0) {//if the distance between the left of the player and the right of the obstacle is the least\r\n            min = birds[i].posX + birds[i].w / 2 - (playerXpos - dinoRun1.width / 2 * scl);\r\n            minIndex = i;\r\n          }\r\n        }\r\n\r\n        if (minIndex == -1) {//if there is only one obejct on the screen\r\n          this.vision[6] = 0; //gap between obstacles\r\n        } else {\r\n          this.vision[6] = 1 / (min - closestDist); //gap between obstacles\r\n        }\r\n      }\r\n    } else {//if replaying then use local shit\r\n      temp = 0;\r\n      min = 10000;\r\n      minIndex = -1;\r\n      berd = false;\r\n      for (var i = 0; i < this.replayObstacles.length; i++) {\r\n        if (this.replayObstacles[i].posX + this.replayObstacles[i].w / 2 - (playerXpos - dinoRun1.width / 2 * scl) < min && this.replayObstacles[i].posX + this.replayObstacles[i].w / 2 - (playerXpos - dinoRun1.width / 2 * scl) > 0) {//if the distance between the left of the player and the right of the obstacle is the least\r\n          min = this.replayObstacles[i].posX + this.replayObstacles[i].w / 2 - (playerXpos - dinoRun1.width / 2 * scl);\r\n          minIndex = i;\r\n        }\r\n      }\r\n\r\n      for (var i = 0; i < this.replayBirds.length; i++) {\r\n        if (this.replayBirds[i].posX + this.replayBirds[i].w / 2 - (playerXpos - dinoRun1.width / 2 * scl) < min && this.replayBirds[i].posX + this.replayBirds[i].w / 2 - (playerXpos - dinoRun1.width / 2 * scl) > 0) {//if the distance between the left of the player and the right of the obstacle is the least\r\n          min = this.replayBirds[i].posX + this.replayBirds[i].w / 2 - (playerXpos - dinoRun1.width / 2 * scl);\r\n          minIndex = i;\r\n          berd = true;\r\n        }\r\n      }\r\n      this.vision[4] = this.localSpeed;\r\n      this.vision[5] = this.posY;\r\n\r\n\r\n      if (minIndex == -1) {//if there are no replayObstacles\r\n        this.vision[0] = 0;\r\n        this.vision[1] = 0;\r\n        this.vision[2] = 0;\r\n        this.vision[3] = 0;\r\n        this.vision[6] = 0;\r\n      } else {\r\n\r\n        this.vision[0] = 1.0 / (min / 10.0);\r\n        if (berd) {\r\n          this.vision[1] = this.replayBirds[minIndex].h;\r\n          this.vision[2] = this.replayBirds[minIndex].w;\r\n          if (this.replayBirds[minIndex].typeOfBird == 0) {\r\n            this.vision[3] = 0;\r\n          } else {\r\n            this.vision[3] = this.replayBirds[minIndex].posY;\r\n          }\r\n        } else {\r\n          this.vision[1] = this.replayObstacles[minIndex].h;\r\n          this.vision[2] = this.replayObstacles[minIndex].w;\r\n          this.vision[3] = 0;\r\n        }\r\n\r\n\r\n\r\n\r\n        //vision 6 is the gap between the this obstacle and the next one\r\n        bestIndex = minIndex;\r\n        closestDist = min;\r\n        min = 10000;\r\n        minIndex = -1;\r\n        for (var i = 0; i < this.replayObstacles.length; i++) {\r\n          if ((berd || i != bestIndex) && this.replayObstacles[i].posX + this.replayObstacles[i].w / 2 - (playerXpos - dinoRun1.width / 2 * scl) < min && this.replayObstacles[i].posX + this.replayObstacles[i].w / 2 - (playerXpos - dinoRun1.width / 2 * scl) > 0) {//if the distance between the left of the player and the right of the obstacle is the least\r\n            min = this.replayObstacles[i].posX + this.replayObstacles[i].w / 2 - (playerXpos - dinoRun1.width / 2 * scl);\r\n            minIndex = i;\r\n          }\r\n        }\r\n\r\n        for (var i = 0; i < this.replayBirds.length; i++) {\r\n          if ((!berd || i != bestIndex) && this.replayBirds[i].posX + this.replayBirds[i].w / 2 - (playerXpos - dinoRun1.width / 2 * scl) < min && this.replayBirds[i].posX + this.replayBirds[i].w / 2 - (playerXpos - dinoRun1.width / 2 * scl) > 0) {//if the distance between the left of the player and the right of the obstacle is the least\r\n            min = this.replayBirds[i].posX + this.replayBirds[i].w / 2 - (playerXpos - dinoRun1.width / 2 * scl);\r\n            minIndex = i;\r\n          }\r\n        }\r\n\r\n        if (minIndex == -1) {//if there is only one obejct on the screen\r\n          this.vision[6] = 0;\r\n        } else {\r\n          this.vision[6] = 1 / (min - closestDist);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n\r\n  //---------------------------------------------------------------------------------------------------------------------------------------------------------\r\n  //gets the output of the brain then converts them to actions\r\n  think() {\r\n\r\n    var max = 0;\r\n    var maxIndex = 0;\r\n    //get the output of the neural network\r\n    this.decision = this.brain.feedForward(this.vision);\r\n\r\n    for (var i = 0; i < this.decision.length; i++) {\r\n      if (this.decision[i] > max) {\r\n        max = this.decision[i];\r\n        maxIndex = i;\r\n      }\r\n    }\r\n\r\n    if (max < 0.7) {\r\n      this.ducking(false);\r\n      return;\r\n    }\r\n\r\n    switch (maxIndex) {\r\n      case 0:\r\n        this.jump(false);\r\n        break;\r\n      case 1:\r\n        this.jump(true);\r\n        break;\r\n      case 2:\r\n        this.ducking(true);\r\n        break;\r\n    }\r\n  }\r\n  //---------------------------------------------------------------------------------------------------------------------------------------------------------  \r\n  //returns a clone of this player with the same brian\r\n  clone() {\r\n    var clone = new Player();\r\n    clone.brain = this.brain.clone();\r\n    clone.fitness = this.fitness;\r\n    clone.brain.generateNetwork();\r\n    clone.gen = this.gen;\r\n    clone.bestScore = this.score;\r\n    return clone;\r\n  }\r\n\r\n  //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n  //since there is some randomness in games sometimes when we want to replay the game we need to remove that randomness\r\n  //this fuction does that\r\n\r\n  cloneForReplay() {\r\n    var clone = new Player();\r\n    clone.brain = this.brain.clone();\r\n    clone.fitness = this.fitness;\r\n    clone.brain.generateNetwork();\r\n    clone.gen = this.gen;\r\n    clone.bestScore = this.score;\r\n    clone.replay = true;\r\n    if (this.replay) {\r\n      arrayCopy(this.localObstacleHistory, clone.localObstacleHistory);\r\n      arrayCopy(this.localRandomAdditionHistory, clone.localRandomAdditionHistory);\r\n    } else {\r\n      // clone.localObstacleHistory = obstacleHistory.clone();\r\n      arrayCopy(obstacleHistory, clone.localObstacleHistory);\r\n      // clone.localRandomAdditionHistory = randomAdditionHistory.clone();\r\n      arrayCopy(randomAdditionHistory, clone.localRandomAdditionHistory);\r\n    }\r\n\r\n    return clone;\r\n  }\r\n\r\n  cloneForJSON() {\r\n    var clone = new Player();\r\n\r\n    clone.fitness = this.fitness;\r\n    clone.replay = this.replay;\r\n    clone.unadjustedFitness = this.unadjustedFitness;\r\n    clone.lifespan = this.lifespan;\r\n    clone.bestScore = this.bestscore;\r\n    clone.dead = this.dead;\r\n    clone.score = this.score;\r\n    clone.gen = this.gen;\r\n\r\n    clone.genomeInputs = this.genomeInputs;\r\n    clone.genomeOutputs = this.genomeOutputs;\r\n\r\n    arrayCopy(this.vision, clone.vision);\r\n    arrayCopy(this.decision, clone.decision);\r\n    clone.posY = this.posY;\r\n    clone.velY = this.velY;\r\n    clone.gravity = this.gravity;\r\n    clone.runCount = this.runCount;\r\n    clone.size = this.size;\r\n\r\n    arrayCopy(this.replayObstacles, clone.replayObstacles);\r\n    arrayCopy(this.replayBirds, clone.replayBirds);\r\n    if (this.replay) {\r\n      arrayCopy(this.localObstacleHistory, clone.localObstacleHistory);\r\n      arrayCopy(this.localRandomAdditionHistory, clone.localRandomAdditionHistory);\r\n    } else {\r\n      // clone.localObstacleHistory = obstacleHistory.clone();\r\n      arrayCopy(obstacleHistory, clone.localObstacleHistory);\r\n      // clone.localRandomAdditionHistory = randomAdditionHistory.clone();\r\n      arrayCopy(randomAdditionHistory, clone.localRandomAdditionHistory);\r\n    }\r\n    clone.historyCounter = this.historyCounter;\r\n    clone.localObstacleTimer = this.localObstacleTimer;\r\n    clone.localSpeed = this.localSpeed;\r\n    clone.localSpeedIncrement = this.localSpeedIncrement;\r\n    clone.localRandomAddition = this.localRandomAddition;\r\n\r\n    clone.duck = this.duck;\r\n    clone.brain = this.brain.cloneForJSON();\r\n\r\n    return clone;\r\n  }\r\n\r\n  //---------------------------------------------------------------------------------------------------------------------------------------------------------\r\n  //fot Genetic algorithm\r\n  calculateFitness() {\r\n    this.fitness = this.score * this.score;\r\n  }\r\n\r\n  //---------------------------------------------------------------------------------------------------------------------------------------------------------\r\n  crossover(parent2) {\r\n    var child = new Player();\r\n    child.brain = this.brain.crossover(parent2.brain);\r\n    child.brain.generateNetwork();\r\n    return child;\r\n  }\r\n  //--------------------------------------------------------------------------------------------------------------------------------------------------------\r\n  //if replaying then the dino has local obstacles\r\n  updateLocalObstacles() {\r\n    this.localObstacleTimer++;\r\n    this.localSpeed += this.localSpeedIncrement;\r\n    if (this.historyCounter >= this.localRandomAdditionHistory.length) {\r\n      this.historyCounter = 0;\r\n    } else {\r\n      this.localRandomAddition = this.localRandomAdditionHistory[this.historyCounter];\r\n    }\r\n    if (this.localObstacleTimer > minimumTimeBetweenObstacles + this.localRandomAddition) {\r\n      this.addLocalObstacle();\r\n    }\r\n    groundCounter++;\r\n    if (groundCounter > 10) {\r\n      groundCounter = 0;\r\n      grounds.push(new Ground());\r\n    }\r\n\r\n    this.moveLocalObstacles();\r\n    this.showLocalObstacles();\r\n  }\r\n\r\n  //---------------------------------------------------------------------------------------------------------------------------------------------------------\r\n  moveLocalObstacles() {\r\n    for (var i = 0; i < this.replayObstacles.length; i++) {\r\n      this.replayObstacles[i].move(this.localSpeed);\r\n      if (this.replayObstacles[i].posX < -100) {\r\n        this.replayObstacles.splice(i, 1);\r\n        i--;\r\n      }\r\n    }\r\n\r\n    for (var i = 0; i < this.replayBirds.length; i++) {\r\n      this.replayBirds[i].move(this.localSpeed);\r\n      if (this.replayBirds[i].posX < -100) {\r\n        this.replayBirds.splice(i, 1);\r\n        i--;\r\n      }\r\n    }\r\n    for (var i = 0; i < grounds.length; i++) {\r\n      grounds[i].move(this.localSpeed);\r\n      if (grounds[i].posX < -100) {\r\n        grounds.splice(i, 1);\r\n        i--;\r\n      }\r\n    }\r\n  }\r\n  //------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n  addLocalObstacle() {\r\n    var tempInt = this.localObstacleHistory[this.historyCounter];\r\n    this.historyCounter++;\r\n    if (tempInt < 3) {\r\n      this.replayBirds.push(new Bird(tempInt));\r\n    } else {\r\n      this.replayObstacles.push(new Obstacle(tempInt - 3));\r\n    }\r\n    this.localObstacleTimer = 0;\r\n  }\r\n  //---------------------------------------------------------------------------------------------------------------------------------------------------------\r\n  showLocalObstacles() {\r\n    for (var i = 0; i < grounds.length; i++) {\r\n      grounds[i].show();\r\n    }\r\n    for (var i = 0; i < this.replayObstacles.length; i++) {\r\n      this.replayObstacles[i].show();\r\n    }\r\n\r\n    for (var i = 0; i < this.replayBirds.length; i++) {\r\n      this.replayBirds[i].show();\r\n    }\r\n  }\r\n}","class Population {\r\n  //------------------------------------------------------------------------------------------------------------------------------------------\r\n  //constructor\r\n  constructor(size) {\r\n\r\n    this.pop = [];\r\n    this.bestPlayer;//the best ever player \r\n    this.bestScore = 0;//the score of the best ever player\r\n    this.gen = 0;\r\n    this.innovationHistory = [];\r\n    this.genPlayers = [];\r\n    this.species = [];\r\n\r\n    this.massExtinctionEvent = false;\r\n    this.newStage = false;\r\n    this.populationLife = 0;\r\n\r\n    for (var i = 0; i < size; i++) {\r\n      this.pop.push(new Player());\r\n      this.pop[i].brain.mutate(this.innovationHistory);\r\n      this.pop[i].brain.generateNetwork();\r\n    }\r\n  }\r\n\r\n  fromJSON(obj) {\r\n    for (var key in obj.pop) {\r\n      var player = new Player().fromJSON(obj.pop[key]);\r\n      this.pop.push(player);\r\n    }\r\n    this.bestPlayer = new Player().fromJSON(obj.bestPlayer);\r\n    this.bestScore = obj.bestScore;//the score of the best ever player\r\n    this.gen = obj.gen;\r\n    this.innovationHistory = [];\r\n    for (var key in obj.innovationHistory) {\r\n      var obj1 = obj.innovationHistory[key];\r\n      // var temp = [];\r\n      // arrayCopy(obj1.innovationNumbers,temp);\r\n      var innovationHistory = new connectionHistory(obj1.fromNode, obj1.toNode, obj1.innovationNumber, obj1.innovationNumbers);\r\n      this.innovationHistory.push(innovationHistory);\r\n    }\r\n    for (var key in obj.genPlayers) {\r\n      var player = new Player().fromJSON(obj.genPlayers[key]);\r\n      this.genPlayers.push(player);\r\n    }\r\n    this.species = [];\r\n    for (var key in obj.species) {\r\n      var species = new Species().fromJSON(obj.species[key]);\r\n      this.species.push(species);\r\n    }\r\n\r\n    this.massExtinctionEvent = obj.massExtinctionEvent;\r\n    this.newStage = obj.newStage;\r\n    this.populationLife = obj.populationLife;\r\n\r\n  }\r\n  //------------------------------------------------------------------------------------------------------------------------------------------\r\n  //update all the players which are alive\r\n  updateAlive() {\r\n    this.populationLife++;\r\n    for (var i = 0; i < this.pop.length; i++) {\r\n      if (!this.pop[i].dead) {\r\n        this.pop[i].look();//get inputs for brain \r\n        this.pop[i].think();//use outputs from neural network\r\n        this.pop[i].update();//move the player according to the outputs from the neural network\r\n        if (!showNothing) {\r\n          this.pop[i].show();\r\n        }\r\n      }\r\n    }\r\n  }\r\n  //------------------------------------------------------------------------------------------------------------------------------------------\r\n  //returns true if all the players are dead      sad\r\n  done() {\r\n    for (var i = 0; i < this.pop.length; i++) {\r\n      if (!this.pop[i].dead) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n  //------------------------------------------------------------------------------------------------------------------------------------------\r\n  //sets the best player globally and for this gen\r\n  setBestPlayer() {\r\n    var tempBest = this.species[0].players[0];\r\n    tempBest.gen = this.gen;\r\n\r\n\r\n    //if best this gen is better than the global best score then set the global best as the best this gen\r\n\r\n    if (tempBest.score >= this.bestScore) {\r\n      this.genPlayers.push(tempBest.cloneForReplay());\r\n      console.log(\"old best: \" + this.bestScore);\r\n      console.log(\"new best: \" + tempBest.score);\r\n      this.bestScore = tempBest.score;\r\n      this.bestPlayer = tempBest.cloneForReplay();\r\n      this.bestPlayer.brain.printGenome();\r\n    }\r\n  }\r\n\r\n  saveBests() {\r\n    // save bests to file\r\n    // var jsons = stringify(this.bestPlayer, null, 2);\r\n    // saveStrings(jsons.split('\\n'), 'bestplayers.json', 'json');\r\n    var jsons = [];\r\n    for (var i = 0; i < this.genPlayers.length; i++) {\r\n      var player = this.genPlayers[i].cloneForReplay();\r\n      var genes = player.brain.genes;\r\n      for (var j = 0; j < genes.length; j++) {\r\n        var connectionGene = genes[j];\r\n        connectionGene.fromNode.outputConnections = [];\r\n      }\r\n      jsons.push(player);\r\n    }\r\n    jsons = JSON.stringify(jsons, null, 2);\r\n    saveStrings(jsons.split('\\n'), 'bestplayers.json', 'json');\r\n    console.log(jsons);\r\n  }\r\n\r\n  savePopulation() {\r\n    // save last generation to file\r\n    // var jsons = stringify(this.bestPlayer, null, 2);\r\n    // saveStrings(jsons.split('\\n'), 'bestplayers.json', 'json');\r\n    var players = [];\r\n    for (var i = 0; i < this.pop.length; i++) {\r\n      // var player = this.pop[i].cloneForReplay();\r\n      // var genes = player.brain.genes;\r\n      // for (var j = 0; j < genes.length; j++) {\r\n      //   var connectionGene = genes[j];\r\n      //   connectionGene.fromNode.outputConnections = [];\r\n      var player = this.pop[i].cloneForJSON();\r\n      players.push(player);\r\n    }\r\n\r\n\r\n    var clone = new Population(0);\r\n    clone.pop = players;\r\n    clone.bestPlayer = this.bestPlayer.cloneForJSON();//the best ever player \r\n    clone.bestScore = this.bestScore;//the score of the best ever player\r\n    clone.gen = this.gen;\r\n    arrayCopy(this.innovationHistory, clone.innovationHistory);\r\n    var genplayers = [];\r\n    for (var i = 0; i < this.genPlayers.length; i++) {\r\n      var player = this.genPlayers[i].cloneForJSON();\r\n      // var genes = player.brain.genes;\r\n      // for (var j = 0; j < genes.length; j++) {\r\n      //   var connectionGene = genes[j];\r\n      //   connectionGene.fromNode.outputConnections = [];\r\n      // }\r\n      genplayers.push(player);\r\n    }\r\n    clone.genPlayers = genplayers;\r\n    clone.species = [];\r\n    for (var i = 0; i < this.species.length; i++) {\r\n      clone.species.push(this.species[i].cloneForJSON());\r\n    }\r\n\r\n    clone.massExtinctionEvent = this.massExtinctionEvent;\r\n    clone.newStage = this.newStage;\r\n    clone.populationLife = this.populationLife;\r\n\r\n    var jsons = JSON.stringify(clone, null, 2);\r\n    saveStrings(jsons.split('\\n'), 'population.json', 'json');\r\n    console.log(jsons);\r\n  }\r\n\r\n  // playersToJson(playerArray) {\r\n  //   var jArry = [];\r\n  //   for (var i = 0; i < playerArray.length; i++) {\r\n  //     var player = playerArray[i];\r\n  //     var jObj = {};\r\n  //     jObj.id = i;\r\n  //     jObj.layers = player.brain.layers;\r\n  //     jObj.bias = player.brain.biasNode;\r\n  //     jObj.nodes = [];\r\n  //     for (var j = 0; j < player.brain.nodes.length; j++) {\r\n  //       jObj.nodes.push(player.brain.nodes[j].number);\r\n  //     }\r\n  //     jObj.genes = [];\r\n  //     var temp = [];\r\n  //     for (var j = 0; j < player.brain.genes.length; j++) {\r\n  //       var temp1 = [];\r\n  //       temp1.push(player.brain.genes[j].innovationNo);\r\n  //       temp1.push(player.brain.genes[j].fromNode.number);\r\n  //       temp1.push(player.brain.genes[j].toNode.number);\r\n  //       temp1.push(player.brain.genes[j].enabled);\r\n  //       temp1.push(player.brain.genes[j].fromNode.layer);\r\n  //       temp1.push(player.brain.genes[j].toNode.layer);\r\n  //       temp1.push(player.brain.genes[j].weight);\r\n\r\n  //       temp.push(temp1);\r\n  //     }\r\n  //     arrayCopy(temp, jObj.genes);\r\n  //     jArry.push(jObj)\r\n  //   }\r\n  //   return jArry\r\n  // }\r\n\r\n  playersToJson(playerArray) {\r\n    var jArry = [];\r\n    for (var i = 0; i < playerArray.length; i++) {\r\n      var jObj = stringify(playerArray[i], null, 2);\r\n      jArry.push(jObj)\r\n    }\r\n    return jArry\r\n  }\r\n\r\n  //------------------------------------------------------------------------------------------------------------------------------------------------\r\n  //this function is called when all the players in the population are dead and a new generation needs to be made\r\n  naturalSelection() {\r\n    var previousBest = this.pop[0];\r\n    // if (this.genPlayers.length > 1) {\r\n    //   if (this.gen - this.genPlayers[this.genPlayers.length - 1].gen > 50) {\r\n    //     // no new best player in 50 generation\r\n    //     this.massExtinctionEvent = true;\r\n    //   }\r\n    // }\r\n    this.speciate();//seperate the population into species \r\n    this.calculateFitness();//calculate the fitness of each player\r\n    this.sortSpecies();//sort the species to be ranked in fitness order, best first\r\n    if (this.massExtinctionEvent) {\r\n      this.massExtinction();\r\n      this.massExtinctionEvent = false;\r\n    }\r\n    this.cullSpecies();//kill off\r\n    this.setBestPlayer();//save the best player of this gen\r\n    this.killStaleSpecies();//remove species which haven't improved in the last 15(ish) generations\r\n    this.killBadSpecies();//kill species which are so bad that they cant reproduce\r\n\r\n\r\n    // console.log(\"generation \" + this.gen + \" Number of mutations \" + this.innovationHistory.length + \" species: \" + this.species.length, \"<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\");\r\n\r\n\r\n    var averageSum = this.getAvgFitnessSum();\r\n    var children = [];//the next generation\r\n    // console.log(\"Species:\");\r\n    for (var j = 0; j < this.species.length; j++) {//for each species\r\n      // console.log(\"best unadjusted fitness: \" + this.species[j].bestFitness);\r\n      // for (var i = 0; i < this.species[j].players.length; i++) {\r\n      //   console.log(\"player \" + i, \"fitness: \" + this.species[j].players[i].fitness + \"score \" + this.species[j].players[i].score + ' ');\r\n      // }\r\n      children.push(this.species[j].champ.clone());//add champion without any mutation\r\n\r\n      var NoOfChildren = floor(this.species[j].averageFitness / averageSum * this.pop.length) - 1;//the number of children this species is allowed, note -1 is because the champ is already added\r\n      for (var i = 0; i < NoOfChildren; i++) {//get the calculated amount of children from this species\r\n        children.push(this.species[j].giveMeBaby(this.innovationHistory));\r\n      }\r\n    }\r\n    if (children.length < this.pop.length) {\r\n      children.push(previousBest.clone());\r\n    }\r\n    while (children.length < this.pop.length) {//if not enough babies (due to flooring the number of children to get a whole int) \r\n      children.push(this.species[0].giveMeBaby(this.innovationHistory));//get babies from the best species\r\n    }\r\n    // while (children.length < this.pop.length) {//if not enough babies (due to flooring the number of children to get a whole int) \r\n    //   var player = new Player();\r\n    //   player.gen = this.gen;\r\n    //   player.brain.mutate(this.innovationHistory);\r\n    //   children.push(player);//get babies from the best species\r\n    // }\r\n    this.pop = [];\r\n    arrayCopy(children, this.pop); //set the children as the current population\r\n    this.gen += 1;\r\n    for (var i = 0; i < this.pop.length; i++) {//generate networks for each of the children\r\n      this.pop[i].brain.generateNetwork();\r\n    }\r\n\r\n    this.populationLife = 0;\r\n  }\r\n\r\n  //------------------------------------------------------------------------------------------------------------------------------------------\r\n  //seperate population into species based on how similar they are to the leaders of each species in the previous gen\r\n  speciate() {\r\n    for (var s of this.species) {//empty species\r\n      s.players = [];\r\n    }\r\n    for (var i = 0; i < this.pop.length; i++) {//for each player\r\n      var speciesFound = false;\r\n      for (var s of this.species) {//for each species\r\n        if (s.sameSpecies(this.pop[i].brain)) {//if the player is similar enough to be considered in the same species\r\n          s.addToSpecies(this.pop[i]);//add it to the species\r\n          speciesFound = true;\r\n          break;\r\n        }\r\n      }\r\n      if (!speciesFound) {//if no species was similar enough then add a new species with this as its champion\r\n        this.species.push(new Species(this.pop[i]));\r\n      }\r\n    }\r\n  }\r\n  //------------------------------------------------------------------------------------------------------------------------------------------\r\n  //calculates the fitness of all of the players \r\n  calculateFitness() {\r\n    for (var i = 1; i < this.pop.length; i++) {\r\n      this.pop[i].calculateFitness();\r\n    }\r\n  }\r\n  //------------------------------------------------------------------------------------------------------------------------------------------\r\n  //sorts the players within a species and the species by their fitnesses\r\n  sortSpecies() {\r\n    //sort the players within a species\r\n    for (var s of this.species) {\r\n      s.sortSpecies();\r\n    }\r\n\r\n    //sort the species by the fitness of its best player\r\n    for (var i = 0; i < this.species.length; i++) {\r\n      var max = 0;\r\n      var maxIndex = 0;\r\n      for (var j = i; j < this.species.length; j++) {\r\n        if (this.species[j].bestFitness > max) {\r\n          max = this.species[j].bestFitness;\r\n          maxIndex = j;\r\n        }\r\n      }\r\n      if (maxIndex != 0) {\r\n        var temp = this.species[maxIndex];\r\n        this.species[maxIndex] = this.species[i];\r\n        this.species[i] = temp;\r\n      }\r\n\r\n    }\r\n  }\r\n  //------------------------------------------------------------------------------------------------------------------------------------------\r\n  //kills all species which haven't improved in 15 generations\r\n  killStaleSpecies() {\r\n    for (var i = 2; i < this.species.length; i++) {\r\n      if (this.species[i].staleness >= 15) {\r\n        this.species.splice(i, 1);\r\n        i--;\r\n      }\r\n    }\r\n  }\r\n  //------------------------------------------------------------------------------------------------------------------------------------------\r\n  //if a species sucks so much that it wont even be allocated 1 child for the next generation then kill it now\r\n  killBadSpecies() {\r\n    var averageSum = this.getAvgFitnessSum();\r\n\r\n    for (var i = 1; i < this.species.length; i++) {\r\n      if (this.species[i].averageFitness / averageSum * this.pop.length < 1) {//if wont be given a single child \r\n        this.species.splice(i, 1);//sad\r\n        i--;\r\n      }\r\n    }\r\n  }\r\n  //------------------------------------------------------------------------------------------------------------------------------------------\r\n  //returns the sum of each species average fitness\r\n  getAvgFitnessSum() {\r\n    var averageSum = 0;\r\n    for (var s of this.species) {\r\n      averageSum += s.averageFitness;\r\n    }\r\n    return averageSum;\r\n  }\r\n\r\n  //------------------------------------------------------------------------------------------------------------------------------------------\r\n  //kill the bottom half of each species\r\n  cullSpecies() {\r\n    for (var s of this.species) {\r\n      s.cull(); //kill bottom half\r\n      s.fitnessSharing();//also while we're at it lets do fitness sharing\r\n      s.setAverage();//reset averages because they will have changed\r\n    }\r\n  }\r\n\r\n\r\n  massExtinction() {\r\n    for (var i = 5; i < this.species.length; i++) {\r\n      this.species.splice(i, 1);//sad\r\n      i--;\r\n    }\r\n  }\r\n}","class Species {\r\n  //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ \r\n  //constructor which takes in the player which belongs to the species\r\n  constructor(p) {\r\n    this.players = [];\r\n    this.bestFitness = 0;\r\n    this.champ;\r\n    this.averageFitness = 0;\r\n    this.staleness = 0;//how many generations the species has gone without an improvement\r\n    this.rep;\r\n\r\n    //--------------------------------------------\r\n    //coefficients for testing compatibility \r\n    this.excessCoeff = 1;\r\n    this.weightDiffCoeff = 0.5;\r\n    this.compatibilityThreshold = 3;\r\n    if (p) {\r\n      this.players.push(p);\r\n      //since it is the only one in the species it is by default the best\r\n      this.bestFitness = p.fitness;\r\n      this.rep = p.brain.clone();\r\n      this.champ = p.cloneForReplay();\r\n    }\r\n  }\r\n\r\n  cloneForJSON() {\r\n    var clone = new Species();\r\n    clone.players = [];\r\n    for (var i = 0; i < this.players.length; i++) {\r\n      clone.players.push(this.players[i].cloneForJSON());\r\n    }\r\n    clone.bestFitness = this.bestFitness;\r\n    clone.champ = this.champ.cloneForJSON();\r\n    clone.averageFitness = this.averageFitness;\r\n    clone.staleness = this.staleness;//how many generations the species has gone without an improvement\r\n    clone.rep = this.rep.cloneForJSON();\r\n\r\n    //--------------------------------------------\r\n    //coefficients for testing compatibility \r\n    clone.excessCoeff = this.excessCoeff;\r\n    clone.weightDiffCoeff = this.weightDiffCoeff;\r\n    clone.compatibilityThreshold = this.compatibilityThreshold;\r\n    return clone;\r\n  }\r\n\r\n  fromJSON(obj) {\r\n    this.players = [];\r\n    for (var key in obj.players) {\r\n      this.players.push(new Player().fromJSON(obj.players[key]));\r\n    }\r\n    this.bestFitness = obj.bestFitness;\r\n    this.champ = new Player().fromJSON(obj.champ);\r\n    this.averageFitness = obj.averageFitness;\r\n    this.staleness = obj.staleness;//how many generations the species has gone without an improvement\r\n    this.rep = new Genome().fromJSON(obj.rep);\r\n\r\n    //--------------------------------------------\r\n    //coefficients for testing compatibility \r\n    this.excessCoeff = obj.excessCoeff;\r\n    this.weightDiffCoeff = obj.weightDiffCoeff;\r\n    this.compatibilityThreshold = obj.compatibilityThreshold;\r\n    return this;\r\n  }\r\n\r\n  //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ \r\n  //returns whether the parameter genome is in this species\r\n  sameSpecies(g) {\r\n    var compatibility;\r\n    var excessAndDisjoint = this.getExcessDisjoint(g, this.rep);//get the number of excess and disjoint genes between this player and the current species rep\r\n    var averageWeightDiff = this.averageWeightDiff(g, this.rep);//get the average weight difference between matching genes\r\n\r\n\r\n    var largeGenomeNormaliser = g.genes.length - 20;\r\n    if (largeGenomeNormaliser < 1) {\r\n      largeGenomeNormaliser = 1;\r\n    }\r\n\r\n    compatibility = (this.excessCoeff * excessAndDisjoint / largeGenomeNormaliser) + (this.weightDiffCoeff * averageWeightDiff);//compatablilty formula\r\n    return (this.compatibilityThreshold > compatibility);\r\n  }\r\n\r\n  //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ \r\n  //add a player to the species\r\n  addToSpecies(p) {\r\n    this.players.push(p);\r\n  }\r\n\r\n  //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ \r\n  //returns the number of excess and disjoint genes between the 2 input genomes\r\n  //i.e. returns the number of genes which dont match\r\n  getExcessDisjoint(brain1, brain2) {\r\n    var matching = 0.0;\r\n    for (var i = 0; i < brain1.genes.length; i++) {\r\n      for (var j = 0; j < brain2.genes.length; j++) {\r\n        if (brain1.genes[i].innovationNo == brain2.genes[j].innovationNo) {\r\n          matching++;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n    return (brain1.genes.length + brain2.genes.length - 2 * (matching));//return no of excess and disjoint genes\r\n  }\r\n  //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n  //returns the avereage weight difference between matching genes in the input genomes\r\n  averageWeightDiff(brain1, brain2) {\r\n    if (brain1.genes.length == 0 || brain2.genes.length == 0) {\r\n      return 0;\r\n    }\r\n\r\n\r\n    var matching = 0;\r\n    var totalDiff = 0;\r\n    for (var i = 0; i < brain1.genes.length; i++) {\r\n      for (var j = 0; j < brain2.genes.length; j++) {\r\n        if (brain1.genes[i].innovationNo == brain2.genes[j].innovationNo) {\r\n          matching++;\r\n          totalDiff += abs(brain1.genes[i].weight - brain2.genes[j].weight);\r\n          break;\r\n        }\r\n      }\r\n    }\r\n    if (matching == 0) {//divide by 0 error\r\n      return 100;\r\n    }\r\n    return totalDiff / matching;\r\n  }\r\n  //-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n  //sorts the species by fitness \r\n  sortSpecies() {\r\n\r\n    //selection sort \r\n    for (var i = 0; i < this.players.length; i++) {\r\n      var max = 0;\r\n      var maxIndex = 0;\r\n      for (var j = i; j < this.players.length; j++) {\r\n        if (this.players[j].fitness > max) {\r\n          max = this.players[j].fitness;\r\n          maxIndex = j;\r\n        }\r\n      }\r\n      //swap\r\n      if (maxIndex != 0) {\r\n        var temp = this.players[maxIndex];\r\n        this.players[maxIndex] = this.players[i];\r\n        this.players[i] = temp;\r\n      }\r\n    }\r\n    if (this.players.length == 0) {\r\n      this.staleness = 200;\r\n      return;\r\n    }\r\n    //if new best player\r\n    if (this.players[0].fitness > this.bestFitness) {\r\n      this.staleness = 0;\r\n      this.bestFitness = this.players[0].fitness;\r\n      this.rep = this.players[0].brain.clone();\r\n      this.champ = this.players[0].cloneForReplay();\r\n    } else {//if no new best player\r\n      this.staleness++;\r\n    }\r\n  }\r\n\r\n  //-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n  //simple stuff\r\n  setAverage() {\r\n\r\n    var sum = 0;\r\n    for (var i = 0; i < this.players.length; i++) {\r\n      sum += this.players[i].fitness;\r\n    }\r\n    this.averageFitness = sum / this.players.length;\r\n  }\r\n  //-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n\r\n  //gets baby from the players in this species\r\n  giveMeBaby(innovationHistory) {\r\n    var baby;\r\n    if (random(1) < 0.25) {//25% of the time there is no crossover and the child is simply a clone of a random(ish) player\r\n      baby = this.selectPlayer().clone();\r\n    } else {//75% of the time do crossover \r\n\r\n      //get 2 random(ish) parents \r\n      var parent1 = this.selectPlayer();\r\n      var parent2 = this.selectPlayer();\r\n\r\n      //the crossover function expects the highest fitness parent to be the object and the lowest as the argument\r\n      if (parent1.fitness < parent2.fitness) {\r\n        baby = parent2.crossover(parent1);\r\n      } else {\r\n        baby = parent1.crossover(parent2);\r\n      }\r\n    }\r\n    baby.brain.mutate(innovationHistory);//mutate that baby brain\r\n    return baby;\r\n  }\r\n\r\n  //-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n  //selects a player based on it fitness\r\n  selectPlayer() {\r\n    var fitnessSum = 0;\r\n    for (var i = 0; i < this.players.length; i++) {\r\n      fitnessSum += this.players[i].fitness;\r\n    }\r\n\r\n    var rand = random(fitnessSum);\r\n    var runningSum = 0;\r\n\r\n    for (var i = 0; i < this.players.length; i++) {\r\n      runningSum += this.players[i].fitness;\r\n      if (runningSum > rand) {\r\n        return this.players[i];\r\n      }\r\n    }\r\n    //unreachable code to make the parser happy\r\n    return this.players[0];\r\n  }\r\n  //------------------------------------------------------------------------------------------------------------------------------------------\r\n  //kills off bottom half of the species\r\n  cull() {\r\n    if (this.players.length > 2) {\r\n      for (var i = this.players.length / 2; i < this.players.length; i++) {\r\n        this.players.splice(i, 1);\r\n        i--;\r\n      }\r\n    }\r\n  }\r\n  //------------------------------------------------------------------------------------------------------------------------------------------\r\n  //in order to protect unique players, the fitnesses of each player is divided by the number of players in the species that that player belongs to \r\n  fitnessSharing() {\r\n    for (var i = 0; i < this.players.length; i++) {\r\n      this.players[i].fitness /= this.players.length;\r\n    }\r\n  }\r\n}"]}